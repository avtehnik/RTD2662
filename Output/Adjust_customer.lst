C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 1   


C51 COMPILER V7.20, COMPILATION OF MODULE ADJUST_CUSTOMER
OBJECT MODULE PLACED IN .\Output\Adjust_customer.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Core\code\Adjust_customer.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTE
                    -ND PRINT(.\Output\Adjust_customer.lst) OBJECT(.\Output\Adjust_customer.obj)

line level    source

   1          /*===========================================================
   2           * Copyright (c)      Realtek Semiconductor Corporation, 2005
   3           * All rights reserved.
   4           * ========================================================== */
   5          
   6          /*==================== File Description ===================== */
   7          /**
   8           * @file
   9           *      This file is osd control declaration related functions.
  10           *
  11           * @author      $Author: Dgoetz $
  12           * @date        $Date: 2/12/15 11:01a $
  13           * @version     $Revision: 2 $
  14           * @ingroup Auto
  15           */
  16          
  17          /**
  18           * @addtogroup Auto
  19           * @{
  20           */
  21          
  22          #define _ADJUST_CUSTOMER_C
  23          
  24          /*===================== Module dependency  ================== */
  25          #include "Core\Header\Include.h"
  26          
  27          //--------------------------------------------------
  28          // Description  : Adjust sharpness
  29          // Input Value  : None
  30          // Output Value : None
  31          //--------------------------------------------------
  32          
  33          //--------------------------------------------------
  34          // Description  : Adjust color precessing brightness
  35          // Input Value  : None
  36          // Output Value : None
  37          //--------------------------------------------------
  38          void CAdjustBrightness(void)
  39          {
  40   1              if(_GET_INPUT_SOURCE() == _SOURCE_VGA)
  41   1              {
  42   2                      pData[0] = (0 + stConBriData.Brightness - 50) + stColorTempData.ColorTemp[0];
  43   2                      pData[1] = (0 + stConBriData.Brightness - 50) + stColorTempData.ColorTemp[1];
  44   2                      pData[2] = (0 + stConBriData.Brightness - 50) + stColorTempData.ColorTemp[2];
  45   2              }
  46   1          else
  47   1          {
  48   2                      pData[0] = (0x80 + stConBriData.Brightness - 78);
  49   2                      pData[1] = (0x80 + stConBriData.Brightness - 78);
  50   2                      pData[2] = (0x80 + stConBriData.Brightness - 78);
  51   2          }
  52   1              CAdjustSetBrightness();
  53   1          CAdjustBacklight();
  54   1      }
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 2   

  55          
  56          //--------------------------------------------------
  57          // Description  : Adjust color processing contrast
  58          // Input Value  : None
  59          // Output Value : None
  60          //--------------------------------------------------
  61          void CAdjustContrast(void)
  62          {
  63   1              BYTE cnt;
  64   1      
  65   1              if(_GET_INPUT_SOURCE() == _SOURCE_VGA)
  66   1          {
  67   2                  for(cnt=0;cnt<3;cnt++)
  68   2                      {
  69   3                      //pData[cnt] = (((WORD)stColorTempData.ColorTemp[cnt] * stConBriData.Contrast / 128) > 255) ? 255 : 
             -(BYTE)((WORD)stColorTempData.ColorTemp[cnt] * stConBriData.Contrast / 128);
  70   3                      pData[cnt] = (BYTE)(((WORD)stColorTempData.ColorTemp[cnt+3] * (stConBriData.Contrast+_CONTRAST_MI
             -N) / 128) > 255) ? 255 : (BYTE)((WORD)stColorTempData.ColorTemp[cnt+3] * (stConBriData.Contrast+_CONTRAST_MIN) / 128);
  71   3                      }
  72   2              }                       
  73   1              else
  74   1          {
  75   2                      pData[0] = (0x80 + stConBriData.Contrast - 38);
  76   2                      pData[1] = (0x80 + stConBriData.Contrast - 38);
  77   2                      pData[2] = (0x80 + stConBriData.Contrast - 38);
  78   2              }       
  79   1      
  80   1              CAdjustSetContrast();
  81   1      }
  82          
  83          #if (sRGB_Color_Enhance == _ENABLE)
  84          void CAdjustYpbprhue(BYTE  ucYPbPrhue)
  85          {
  86   1              CAdjustSaturationHue(ucYPbPrhue, _FALSE);
  87   1      }
  88                       /*
  89          
  90          #define _YUV2RGB_k13   1
  91          #define _YUV2RGB_k22   2
  92          #define _YUV2RGB_k23   3
  93          #define _YUV2RGB_k32   4
  94          UINT16 tYUV2RGB_COEF_601_YCbCr[] =
  95          {
  96           
  97            0x0100, // k11
  98            0x0166, // k13
  99            0x0058, // k22
 100            0x00b6, // k23
 101            0x01c5, // k32
 102            0x0000, // R-offset
 103            0x0000, // G-offset
 104            0x0000, // B-offset
 105           
 106            0x0000, // Y Clamp (Y-16)
 107            0x0001, // UV Clamp (UV-512)
 108           
 109          };              */
 110          
 111          void CAdjustYpbprSaturation(BYTE  ucYPbPrSaturation)
 112          {
 113   1              WORD PB,PR;//,new_k13,new_k22,new_k23,new_k32,new_coeffs;
 114   1              BYTE temp;
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 3   

 115   1      
 116   1              temp=ucYPbPrSaturation;
 117   1          // EricLee add
 118   1              CScalerPageSelect(_PAGE7);
 119   1          if (ucYPbPrSaturation < 11)
 120   1          {
 121   2              PR = (WORD)ucYPbPrSaturation*102;
 122   2              CScalerSetByte(0xD8, (BYTE)(PR>>8) | _BIT6);
 123   2              CScalerSetByte(0xD9, (BYTE)PR);
 124   2          }
 125   1          else
 126   1              CScalerSetByte(0xD8, 0x00);
 127   1      
 128   1          if(_GET_INPUT_SOURCE() == _SOURCE_YPBPR)
 129   1          {
 130   2              PR = (temp <= 50)  ? ((WORD)stYPbPrData.YPbPrGain[_RED] + ((50 - temp) << 2)) :
 131   2              ((WORD)stYPbPrData.YPbPrGain[_RED] - (temp - 50));
 132   2          
 133   2              PB = (temp <= 50)  ? ((WORD)stYPbPrData.YPbPrGain[_BLUE] + ((50 - temp) << 2)) :
 134   2              ((WORD)stYPbPrData.YPbPrGain[_BLUE] - (temp - 50));
 135   2          
 136   2              if(HIBYTE(PB)>0)
 137   2                      PB  = HIBYTE(PB) < 0x02 ? 0x00FF : 0 ;
 138   2              if (HIBYTE(PR)>0)
 139   2                      PR  = HIBYTE(PR) < 0x02 ? 0x00FF : 0 ;
 140   2          
 141   2              #if(_ADC1_INPUT_SWAP_RG == _ON)
                      pData[1] = PR;
                      pData[0] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[2] = PB;
                      #elif(_ADC1_INPUT_SWAP_RB == _ON)
                      pData[2] = PR;
                      pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[0] = PB;
                      #elif(_ADC1_INPUT_SWAP_GB == _ON)
 150   2              pData[0] = PR;
 151   2              pData[2] = stYPbPrData.YPbPrGain[_GREEN];
 152   2              pData[1] = PB;
 153   2              #else
                      pData[0] = PR;
                      pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[2] = PB;
                      #endif
 158   2      
 159   2              //CAdjustSetYpbprSaturation();//eric 20070613
 160   2              CAdjustSaturationHue(ucYPbPrSaturation, _TRUE);
 161   2          }
 162   1      
 163   1              //Lewis, adjust sRGB domain
 164   1              CAdjustSaturationHue(ucYPbPrSaturation, _TRUE);
 165   1                        /*
 166   1      
 167   1          new_coeffs =  (double)  tYUV2RGB_COEF_601_YCbCr[_YUV2RGB_k13] * ucYPbPrSaturation;
 168   1          new_coeffs = (new_coeffs >> 7) ;
 169   1          new_k13 = (new_coeffs > 0x1ff) ? 0x1ff: new_coeffs;
 170   1          
 171   1          new_coeffs = (double)  tYUV2RGB_COEF_601_YCbCr[_YUV2RGB_k22]  * ucYPbPrSaturation;
 172   1          new_coeffs = (new_coeffs >> 7) ;
 173   1          
 174   1          new_k22 = (new_coeffs > 0xff) ? 0xff: new_coeffs;
 175   1          
 176   1          new_coeffs = (double)   tYUV2RGB_COEF_601_YCbCr[_YUV2RGB_k23]  * ucYPbPrSaturation;
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 4   

 177   1          new_coeffs = (new_coeffs >> 7) ;
 178   1          
 179   1          new_k23 = (new_coeffs > 0xff) ? 0xff: new_coeffs;
 180   1          
 181   1          new_coeffs = (double)   tYUV2RGB_COEF_601_YCbCr[_YUV2RGB_k32]  * ucYPbPrSaturation;
 182   1          new_coeffs = (new_coeffs >> 7) ;
 183   1          
 184   1          new_k32 = (new_coeffs > 0x3ff) ? 0x3ff: new_coeffs;
 185   1      
 186   1      
 187   1              CScalerPageSelect(_PAGE7);
 188   1          CScalerSetByte(_P7_YUV2RGB_ACCESS_C0,(WORD)(new_k13 >> 8));
 189   1          CScalerSetByte(_P7_YUV2RGB_DATA_C1,(WORD)(new_k13 & 0xFF));
 190   1          CScalerSetByte(_P7_YUV2RGB_ACCESS_C0,(WORD)(new_k22 >> 8));
 191   1          CScalerSetByte(_P7_YUV2RGB_DATA_C1,(WORD)(new_k22 & 0xFF));
 192   1          CScalerSetByte(_P7_YUV2RGB_ACCESS_C0,(WORD)(new_k23 >> 8));
 193   1          CScalerSetByte(_P7_YUV2RGB_DATA_C1,(WORD)(new_k23 & 0xFF));
 194   1          CScalerSetByte(_P7_YUV2RGB_ACCESS_C0,(WORD)(new_k32 >> 8));
 195   1          CScalerSetByte(_P7_YUV2RGB_DATA_C1,(WORD)(new_k32 & 0xFF)); */
 196   1      }
 197          
 198          #else
              
              // cftsai 20061031 modify
              INT16 code RR[]=
              {
              -155,-149,-143,-138,-132,-127,-121,-116,-111,-105,
              -100, -95, -90, -85, -80, -75, -71, -66, -62, -57,
               -53, -49, -45, -40, -36, -33, -29, -25, -22, -18,
               -15, -12,  -8,  -5,  -2,   0,   2,   5,   7,  10,
                12,  14,  16,  18,  20,  22,  24,  25,  26,  28,
                29,  30,  31,  32,  32,  33,  33,  34,  34,  34,
                34,  34,  34,  33,  33,  32,  32,  31,  30,  29,
                28
              };
              
              INT16 code RG[]=
              {
              -100, -99, -98, -96, -95, -93, -92, -90, -88, -86,
               -84, -81, -79, -77, -74, -72, -69, -66, -63, -60,
               -57, -54, -51, -47, -44, -40, -36, -33, -29, -25,
               -21, -17, -13,  -8,  -4,   0,   4,   9,  13,  18,
                23,  28,  33,  38,  43,  48,  53,  58,  64,  69,
                74,  80,  86,  91,  97, 102, 108, 114, 120, 126,
               132, 138, 144, 150, 156, 162, 168, 174, 180, 186,
               193
              };
              
              INT16 code RB[]=
              {
              255, 249, 242, 235, 227, 220, 213, 206, 199, 192,
              184, 177, 170, 162, 155, 148, 140, 133, 125, 118,
              110, 103,  96,  88,  81,  73,  66,  58,  51,  44,
               36,  29,  21,  14,   7,   0,  -7, -14, -21, -28,
              -35, -42, -49, -56, -63, -70, -77, -84, -91, -97,
              -104, -110, -117, -123, -130, -136, -142, -148, -154, -160,
              -166, -172, -178, -184, -189, -195, -200, -205, -211, -216,
              -221
              };
              
              INT16 code GR[]=
              {
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 5   

              162 ,157 ,152 ,147 ,142 ,137 ,132 ,127 ,
              122 ,117 ,113 ,108 ,103 ,98  ,93  ,88  ,
              84  ,79  ,74  ,70  ,65  ,60  ,56  ,51  ,
              47  ,42  ,38  ,33  ,29  ,25  ,20  ,16  ,
              12  ,8   ,4   ,0   ,-4  ,-7  ,-11 ,-15 ,
              -19 ,-23 ,-27 ,-30 ,-34 ,-37 ,-41 ,-44 ,
              -48 ,-51 ,-54 ,-57 ,-60 ,-63 ,-66 ,-69 ,
              -72 ,-75 ,-77 ,-80 ,-83 ,-85 ,-87 ,-90 ,
              -92 ,-94 ,-96 ,-98 ,-100,-102,-104
              };
              
              INT16 code GG[]=
              {
              -9 ,-7 ,-6 ,-4 ,-3 ,-2 ,-1 ,0  ,
              1  ,2  ,3  ,3  ,4  ,5  ,5  ,6  ,
              6  ,7  ,7  ,7  ,7  ,7  ,7  ,7  ,
              7  ,7  ,6  ,6  ,5  ,5  ,4  ,3  ,
              2  ,2  ,1  ,0  ,-1 ,-2 ,-3 ,-5 ,
              -6 ,-8 ,-9 ,-11,-13,-15,-16,-18,
              -20,-23,-25,-27,-29,-32,-34,-37,
              -39,-42,-45,-48,-51,-53,-56,-60,
              -63,-66,-69,-72,-76,-79,-83
              };
              
              INT16 code GB[]=
              {
              -152,-149,-145,-142,-138,-135,-131,-127,
              -123,-120,-116,-112,-108,-103,-99 ,-95 ,
              -91 ,-86 ,-82 ,-77 ,-73 ,-68 ,-64 ,-59 ,
              -54 ,-49 ,-45 ,-40 ,-35 ,-30 ,-25 ,-20 ,
              -15 ,-10 ,-5  ,0   ,5   ,10  ,15  ,20  ,
              26  ,31  ,36  ,42  ,47  ,52  ,58  ,63  ,
              69  ,74  ,79  ,85  ,90  ,96  ,101 ,107 ,
              112 ,117 ,123 ,128 ,134 ,139 ,144 ,150 ,
              155 ,160 ,166 ,171 ,176 ,181 ,187
              };
              
              INT16 code BR[]=
              {
              -172, -169, -165, -162 , -158, -154, -150, -146, -142, -138,
              -133, -129, -124,-120,-115,-110,-105,-100,-95,-90,
              -85,-80,-75,-69,-64,-58,-53,-47,-41,-35,
              -30,-24,-18,-12,-6,0,6,12,18,24,
              31,37,44,50,57,63,70,76,83,89,
              96,103,109,116,123,130,136,143,150,157,
              163,170,177,183,190,197,204,210,217,224,
              230
              };
              
              INT16 code BG[]=
              {
              193 ,186 ,180 ,174 ,168 ,162 ,156 ,150 ,
              144 ,138 ,132 ,126 ,120 ,114 ,108 ,102 ,
              97  ,91  ,86  ,80  ,74  ,69  ,64  ,58  ,
              53  ,48  ,43  ,38  ,33  ,28  ,23  ,18  ,
              13  ,9   ,4   ,0   ,-4  ,-8  ,-13 ,-17 ,
              -21 ,-25 ,-29 ,-33 ,-36 ,-40 ,-44 ,-47 ,
              -51 ,-54 ,-57 ,-60 ,-63 ,-66 ,-69 ,-72 ,
              -74 ,-77 ,-79 ,-81 ,-84 ,-86 ,-88 ,-90 ,
              -92 ,-93 ,-95 ,-96 ,-98 ,-99 ,-100
              };
              
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 6   

              INT16 code BB[]=
              {
              -20 ,-17, -14, -12, -9, -7, -5, -3,
              -1  ,0   ,1   ,3   ,4   ,5   ,6   ,7   ,
              8   ,9   ,9   ,10  ,10  ,10  ,10  ,10  ,
              10  ,10  ,9   ,9   ,8   ,7   ,6   ,5   ,
              4   ,3   ,1   ,0   ,-1  ,-3  ,-5  ,-7  ,
              -9  ,-12 ,-14 ,-17 ,-20 ,-22 ,-25 ,-29 ,
              -32 ,-35 ,-39 ,-42 ,-46 ,-50 ,-53 ,-57 ,
              -62 ,-66 ,-70 ,-75 ,-79 ,-84 ,-88 ,-93 ,
              -98 ,-103,-108,-114,-119,-124,-130
              };
              
              void CAdjustYpbprhue(BYTE  ucYPbPrhue)
              {
                      BYTE uchue ;
              
                      uchue = ucYPbPrhue *0.7 ;
                      //Write R
                      pData[0] = ((RR[uchue] >> 8) & 0x01);   // RRH
                      pData[1] = (RR[uchue] & 0xff);          // RRL
                      pData[2] = ((RG[uchue] >> 8) & 0x01);   // RGH
                      pData[3] = (RG[uchue] & 0xff);          // RGL
                      pData[4] = ((RB[uchue] >> 8) & 0x01);   // RBH
                      pData[5] = (RB[uchue] & 0xff);          // RBL
                      CAdjustSetYpbprRhue();
              
                      //Write G
                      pData[0] = ((GR[uchue] >> 8) & 0x01);   // GRH
                      pData[1] = (GR[uchue] & 0xff);          // GRL
                      pData[2] = ((GG[uchue] >> 8) & 0x01);   // GGH
                      pData[3] = (GG[uchue] & 0xff);          // GGL
                      pData[4] = ((GB[uchue] >> 8) & 0x01);   // GBH
                      pData[5] = (GB[uchue] & 0xff);          // GBL
                      CAdjustSetYpbprGhue();
              
                      //Write B
                      pData[0] = ((BR[uchue] >> 8) & 0x01);   // BRH
                      pData[1] = (BR[uchue] & 0xff);          // BRL
                      pData[2] = ((BG[uchue] >> 8) & 0x01);   // BGH
                      pData[3] = (BG[uchue] & 0xff);          // BGL
                      pData[4] = ((BB[uchue] >> 8) & 0x01);   // BBH
                      pData[5] = (BB[uchue] & 0xff);          // BBL
                      CAdjustSetYpbprBhue();
              
                      CScalerSetBit(_COLOR_CTRL_62, 0xff, 0x80);                      // cftsai 20061031 added, ready to write
              }
              
              void CAdjustYpbprSaturation(BYTE  ucYPbPrSaturation)
              {
                  WORD    PB, PR ;
              
                      PR = (WORD)stYPbPrData.YPbPrGain[_RED] * (100 - ucYPbPrSaturation) /(WORD)50  ;
                      PB = (WORD)stYPbPrData.YPbPrGain[_BLUE] * (100 - ucYPbPrSaturation) /(WORD)50 ;
                      if(HIBYTE(PB)>0)
                              PB  = 0x00FF ;
                      if (HIBYTE(PR)>0)
                              PR  = 0x00FF ;
              
                      #if(_ADC1_INPUT_SWAP_RG == _ON)
                  pData[1] = PR;
                  pData[0] = stYPbPrData.YPbPrGain[_GREEN];
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 7   

                  pData[2] = PB;
                      #elif(_ADC1_INPUT_SWAP_RB == _ON)
                  pData[2] = PR;
                  pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                  pData[0] = PB;
                      #elif(_ADC1_INPUT_SWAP_GB == _ON)
                  pData[0] = PR;
                  pData[2] = stYPbPrData.YPbPrGain[_GREEN];
                  pData[1] = PB;
                      #else
                  pData[0] = PR;
                  pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                  pData[2] = PB;
                      #endif
              
                      CAdjustSetYpbprSaturation();
              }
              #endif          // sRGB_Color_Enhance end
 381          
 382          #if(_AdjustCustomerColorMode==_ENABLE)
              void CAdjustCustomerColorMode(void)
              {
                      #if(_COLOR_PREFERENCE == _PANASONIC_STYLE)
                      // Brightness_R,Brightness_G,Brightness_B,Contrast_R,Contrast_G,Contrast_B,Sharpness_Num
                      // VDC_Contrast,VDC_Brightness,VDC_Saturation,VDC_Hue,VDC_Shaprness
              
                      BYTE code ColorType[][12] = {
                      // CVBS,SV
                      //    B_R    B_G   B_B     C_R    C_G    C_B    Sharp   VD_Con   VD_Bri   VD_Sat   VD_Hue    VD_Sharp
                              0x80,  0x80,  0x7F,  0x87,  0x80,  0x7A,   6,        38,           0x78,     64,         46,          0x
             -17,
              
                      // TV
                      //    B_R    B_G   B_B     C_R    C_G    C_B    Sharp   VD_Con   VD_Bri   VD_Sat   VD_Hue    VD_Sharp
                              0x80,  0x80,  0x80,  0x80,  0x80,  0x80,  6,        52,           0x85,     52,         47,          0x1
             -7,
                         //0x80,  0x80,  0x80,  0x80,  0x80,  0x80,   6,        33,           0x85,     58,         46,        
             -  0x17,
              
                      // YPbPr  , HDMI
                      //    B_R    B_G   B_B     C_R    C_G    C_B    Sharp   VD_Con   VD_Bri   VD_Sat   VD_Hue    VD_Sharp
                              0x80,  0x80,  0x7F,  0xB3,  0xAA,  0xA2,   6,        38,           0x78,     50,         50,          0x
             -17,
                         //0x80,  0x80,  0x7F,  0xB3,  0xAA,  0xA2,   6,        38,           0x78,     50,         50,        
             -  0x17,
                      };
              
                      if(!bSourceVideo())
                      {
                              pData[0] = ColorType[2][0];
                              pData[1] = ColorType[2][1];
                              pData[2] = ColorType[2][2];
                              pData[3] = ColorType[2][3];
                              pData[4] = ColorType[2][4];
                              pData[5] = ColorType[2][5];
              
                              CScalerSetByte(_CB_ACCESS_PORT_64, 0x80);
                              CScalerWrite(_CB_DATA_PORT_65, 6, pData, _NON_AUTOINC);
                              CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
              
                              SET_PEAKING_CORING(ColorType[2][6]);
                              SET_CONTRAST(ColorType[2][7]);
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 8   

                              //SET_YPbPrSaturation(ColorType[2][9]);
                              //SET_YPbPrHue(ColorType[2][10]);
                      SET_SATURATION(ColorType[2][9]);
                              SET_HUE(ColorType[2][10]);                      
                              CEepromSaveSystemData();
              
                              CAdjustPeakingFilter(GET_PEAKING_CORING());
                              CAdjustContrast();
                              //CAdjustYpbprSaturation(GET_YPbPrSaturation());
                              //CAdjustYpbprhue(GET_YPbPrHue());
                              CAdjustYpbprSaturation(GET_SATURATION());
                              CAdjustYpbprhue(50);//GET_HUE());
                              CScalerSetBit(_COLOR_CTRL_62, 0xFF, _BIT2);
                      }
                      else
                      {       
                              if(_GET_INPUT_SOURCE() == _SOURCE_VIDEO_TV)
                              {       
                                      pData[0] = ColorType[1][0];
                                      pData[1] = ColorType[1][1];
                                      pData[2] = ColorType[1][2];
                                      pData[3] = ColorType[1][3];
                                      pData[4] = ColorType[1][4];
                                      pData[5] = ColorType[1][5];
              
                                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x80);
                              CScalerWrite(_CB_DATA_PORT_65, 6, pData, _NON_AUTOINC);
                              CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
              
                                      SET_PEAKING_CORING(ColorType[1][6]);
                                      SET_CONTRAST(ColorType[1][7]);
                                      SET_SATURATION(ColorType[1][9]);
                                      SET_HUE(ColorType[1][10]);
                                      CVideoSetVDCBrightness(ColorType[1][8]);
                                      I2CByteWrite(0x80,_VIDEO_DEVICE,ColorType[1][11]);
                                      
                                      CEepromSaveSystemData();
                              }
                              else
                              {       
                                      pData[0] = ColorType[0][0];
                                      pData[1] = ColorType[0][1];
                                      pData[2] = ColorType[0][2];
                                      pData[3] = ColorType[0][3];
                                      pData[4] = ColorType[0][4];
                                      pData[5] = ColorType[0][5];
              
                                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x80);
                              CScalerWrite(_CB_DATA_PORT_65, 6, pData, _NON_AUTOINC);
                              CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
              
                                      SET_PEAKING_CORING(ColorType[0][6]);
                                      SET_CONTRAST(ColorType[0][7]);
                                      SET_SATURATION(ColorType[0][9]);
                                      SET_HUE(ColorType[0][10]);
                                      CVideoSetVDCBrightness(ColorType[0][8]);
                                  I2CByteWrite(0x80,_VIDEO_DEVICE,ColorType[0][11]);
                                      
                                      CEepromSaveSystemData();
                              }
                              CAdjustPeakingFilter(GET_PEAKING_CORING());
                              CVideoSetContrast(GET_CONTRAST());
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 9   

                              CVideoSetSaturation(GET_SATURATION());
                              gmi_CAdjustVDCHue(GET_HUE());           
                      }
                      #endif
              
                      #if(sRGB_Color_Enhance == _ENABLE)
                      CVideoSetSaturation(GET_SATURATION());
                      gmi_CAdjustVDCHue(GET_HUE());
                      CScalerSetBit(_COLOR_CTRL_62, ~(_BIT2), _BIT2);         // enable sRGB
                      #endif
              }
              #endif
 494          
 495          #if(_VIDEO_AUTO_WHITE_BLANCE == _ENABLE)
 496          #define _VIDEO_SATURATION_MAX   0xFF
 497          #define _VIDEO_SATURATION_MIN   0x00
 498          #endif
 499          
 500          //--------------------------------------------------
 501          // Description  : Set  2610 Saturation
 502          // Input Value  : saturationNone
 503          // Output Value : None
 504          //--------------------------------------------------
 505           void CVideoSetSaturation(BYTE ucValue)
 506          {
 507   1              #if(_VIDEO_AUTO_WHITE_BLANCE == _ENABLE)
 508   1              BYTE ucSaturation;
 509   1              BYTE temp;
 510   1      
 511   1              ucSaturation = 0x80;//230;//0xA0;//140;//GET_VDC_CHROMA();
 512   1              if(ucValue > 50)
 513   1          {
 514   2                      temp = ((UINT16)((_VIDEO_SATURATION_MAX - ucSaturation)*(ucValue - 50))) / 50;
 515   2                      temp += ucSaturation;
 516   2              }
 517   1              else if(ucValue < 50)
 518   1          {
 519   2                      temp = ((UINT16)((ucSaturation -_VIDEO_SATURATION_MIN) * (50 - ucValue))) / 50;
 520   2                      temp = ucSaturation - temp;
 521   2              }
 522   1              else
 523   1                      temp = ucSaturation;
 524   1              CVideoSetVDCSaturation(temp);
 525   1              #else
                      ucValue = ucValue * 2.5;
                      CVideoSetVDCSaturation(ucValue);
                      #endif
 529   1      }
 530          
 531          //--------------------------------------------------
 532          // Description  : Set  2610 Contrast
 533          // Input Value  : ucValue
 534          // Output Value : None
 535          //--------------------------------------------------
 536          void CVideoSetContrast(BYTE ucValue)
 537          {
 538   1              ucValue = ucValue * 2.5;
 539   1          CVideoSetVDCContrast(ucValue);
 540   1      }
 541          
 542          void CAdjustHueSatSet(BYTE color, SWORD TempU1, SWORD TempU2, SWORD TempV1, SWORD TempV2)
 543          {
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 10  

 544   1          BYTE i;
 545   1          SWORD u,v;
 546   1      
 547   1          BYTE value = (color & 0x0f);
 548   1              //CTimerWaitForEvent(_EVENT_DEN_STOP);
 549   1              CScalerPageSelect(_PAGE7);
 550   1      
 551   1          CScalerSetByte(_P7_ICM_SEL_D1, value);
 552   1          CScalerSetByte(_P7_ICM_ACCESS_PORT_D2,0x00);
 553   1          if(value == 0)
 554   1          {           //R
 555   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x02);
 556   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xd2);
 557   2                      if(CGetInputSourceNum(_GET_INPUT_SOURCE())>1)
 558   2                      CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xaa);
 559   2                      else
 560   2                              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xee);
 561   2          }
 562   1              else if(value == 1)
 563   1          {//G
 564   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x08);
 565   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x00);
 566   2                      if(CGetInputSourceNum(_GET_INPUT_SOURCE())>1)
 567   2                      CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x66);
 568   2                      else
 569   2                              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xee);
 570   2          }
 571   1          else if(value == 2)
 572   1          {//B
 573   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x0d);
 574   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x2e);
 575   2                      if(CGetInputSourceNum(_GET_INPUT_SOURCE())>1)
 576   2                              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x66);
 577   2              else
 578   2                              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xbe);
 579   2          }
 580   1          else if(value == 3)
 581   1          {//Y
 582   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x05);
 583   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x2e);
 584   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x62);  //ff
 585   2          }
 586   1          else if(value == 4)
 587   1          {//C
 588   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x0a);
 589   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xd2);
 590   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x66);
 591   2          }
 592   1          //CTimerWaitForEvent(_EVENT_DEN_STOP);
 593   1          CScalerSetByte(_P7_ICM_SEL_D1,value);
 594   1          CScalerSetByte(_P7_ICM_ACCESS_PORT_D2,((color & 0xf0)+0x03));
 595   1              //CScalerSendAddr(_P7_ICM_DATA_PORT_D3, _WRITE, _NON_AUTOINC);//provisional ¼È©w
 596   1              
 597   1          for(i=1; i<9; i++)
 598   1          {
 599   2                      u = ((TempU1+TempU2)*CAdjustColorGammaCal(value, i)/64) - ((TempU1*i)/8);
 600   2                      v = ((TempV1+TempV2)*CAdjustColorGammaCal(value, i)/64) - ((TempV1*i)/8);
 601   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,u); //CScalerSetByte(0xe3,u);               
 602   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,v); //CScalerSetByte(0xe3,v);               
 603   2          }
 604   1              if(_GET_INPUT_SOURCE() == _SOURCE_VGA || _GET_INPUT_SOURCE() == _SOURCE_DVI)//CGetInputSourceNum(_GET_IN
             -PUT_SOURCE())>1)
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 11  

 605   1                      CScalerSetByte(_P7_ICM_CTRL_D0,0xdf);
 606   1              else
 607   1                      CScalerSetByte(_P7_ICM_CTRL_D0,0xdc);
 608   1      }
 609          
 610          #define CENTER    0x00
 611          #define RIGHT     0x10
 612          #define LEFT      0x20
 613          void CAdjustSetHueUVDelta(BYTE color, BYTE select)
 614          {
 615   1          SWORD TempU1,TempV1,TempU2,TempV2;
 616   1      
 617   1              pData[0] = (select >> 3); //(select >> 4) << 1
 618   1              pData[1] = pData[0] + 1;
 619   1      
 620   1              if(CGetInputSourceNum(_GET_INPUT_SOURCE())>1)
 621   1              {
 622   2                TempU1 = Video_TempUV1[color][pData[0]];
 623   2                TempV1 = Video_TempUV1[color][pData[1]];
 624   2              }
 625   1              else
 626   1              {
 627   2                TempU1 = Graphic_TempUV1[color][pData[0]];
 628   2                TempV1 = Graphic_TempUV1[color][pData[1]];
 629   2              }
 630   1      
 631   1              pData[2] = color*3 + (select >> 4);
 632   1      
 633   1              if(stICMColor.ICM_COLOR[color] < 8)
 634   1              {
 635   2                 TempU2 = (long)TempUV2[pData[2]][0] * (8 - stICMColor.ICM_COLOR[color]) >> 3;
 636   2                 TempV2 = (long)TempUV2[pData[2]][1] * (8 - stICMColor.ICM_COLOR[color]) >> 3;
 637   2              }
 638   1              else
 639   1              {
 640   2                 TempU2 = (long)TempUV2[pData[2]][2] * (stICMColor.ICM_COLOR[color] - 8) >> 3;
 641   2                 TempV2 = (long)TempUV2[pData[2]][3] * (stICMColor.ICM_COLOR[color] - 8) >> 3;
 642   2              }
 643   1              CAdjustHueSatSet((select | color), TempU1, TempU2, TempV1, TempV2);
 644   1      }
 645          
 646          #if(_COLOR_PREFERENCE == _PANASONIC_STYLE)
 647          
 648          #define RF_StartOffset          5
 649          #define AV_StartOffset          0
 650          #define YPbPr_StartOffset       0
 651          
 652          // 0xFF -1   0xFE -2
 653          void CAdjustPeakingFilter(SBYTE ucPeaking)
 654          {
 655   1              WORD GainPos,GainNeg;
 656   1      
 657   1              if(_GET_INPUT_SOURCE() == _SOURCE_VGA || _GET_INPUT_SOURCE() == _SOURCE_DVI || _GET_INPUT_SOURCE() == _SO
             -URCE_HDMI)
 658   1          {
 659   2                      CScalerPageSelect(_PAGE7);
 660   2                      CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, 0x00);     // disable Peaking and Coring
 661   2              CScalerSetBit(_P7_DLTI_DCTI_ENABLE_A1, ~(_BIT6 | _BIT7), 0x00);
 662   2                      CScalerPageSelect(_PAGE6);
 663   2              CScalerSetByte(_P6_DCTI_1ST_GAIN_D8, 0x4A);
 664   2              CScalerSetByte(_P6_SPATIAL_CTRL_DB, 0x00);
 665   2                      return;
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 12  

 666   2              }
 667   1              else if(_GET_INPUT_SOURCE() == _SOURCE_YPBPR)
 668   1          {
 669   2                      //if(HDMI_V_Height>=720)                //720p above
 670   2                              pData[0] = 0x00;                                        //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
 671   2                      //else
 672   2                              //pData[0] = 0x00;                                      //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
 673   2                      pData[1] = 0x7E;                                                //Peaking_C0 (126) 
 674   2                      pData[2] = 0xF7;                                                //Peaking_C1 (-19)      
 675   2                      pData[3] = 0x4A;                                                //Peaking_C2 (82)
 676   2                      pData[4] = 0x00;                                                //Gain_Blur
 677   2                      GainPos  = ucPeaking * 195;
 678   2                      GainPos  = GainPos   / 100; //Gain_Pos(Min~Max)
 679   2                      GainNeg  = ucPeaking * 195;
 680   2                      GainNeg  = GainNeg   / 100; //Gain_Neg(Min~Max)
 681   2                      pData[7] = 0x00;                                                //Pos_Range(MSB)+Neg_Range(MSB)
 682   2                      pData[8] = 0x20;                                                //Pos_Range(LSB)(1023)
 683   2                      pData[9] = 0x40;                                                //Neg_Range(LSB)(1023)
 684   2                      pData[10] = 0x0E;                                       //Coring(LV_min~LV_max)                 
 685   2              }       
 686   1              else
 687   1          {//AV SV TV
 688   2                   #if 1
 689   2                      pData[0] = 0x00; //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels        
 690   2                      pData[1] = 0x7E; //Peaking_C0 (126) 
 691   2                      pData[2] = 0xF7; //Peaking_C1 (-9)  
 692   2                      pData[3] = 0x4A; //Peaking_C2 (74)
 693   2                      pData[4] = 0x00; //Gain_Blur
 694   2                      GainPos  = (ucPeaking*3);
 695   2                      GainPos  = GainPos /5; //Gain_Pos(Min~Max)
 696   2                      GainNeg  = (ucPeaking * 26);
 697   2                      GainNeg  = GainNeg /25; //Gain_Neg(Min~Max)
 698   2                      pData[7] = 0x00; //Pos_Range(MSB)+Neg_Range(MSB)
 699   2                      pData[8] = 0x96;//0x30;//0x08;//0x96; //Pos_Range(LSB)(150)
 700   2                      pData[9] = 0xFF;  //Neg_Range(LSB)(255)
 701   2                      pData[10] = 0x06; //Coring(LV_min~LV_max)
 702   2                   #else
                              pData[0] = 0x00;                                            //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels                     
                              pData[1] = 0x7E;                                                //Peaking_C0  
                              pData[2] = 0x0B;                                                //Peaking_C1    
                              pData[3] = 0x36;                                                //Peaking_C2 
                              pData[4] = 0x00;                                                //Gain_Blur
                              pData[5] = (WORD)(ucPeaking*255)/100;   //Gain_Pos(Min~Max)
                              pData[6] = (WORD)(ucPeaking*255)/100;   //Gain_Neg(Min~Max)
                              pData[7] = 0x00;                                                //Pos_Range(MSB)+Neg_Range(MSB)
                              pData[8] = 0x08;                                                //Pos_Range(LSB)(1023)
                              pData[9] = 0x80;                                                //Neg_Range(LSB)(1023)
                              pData[10] = 0x05;                                           //Coring(LV_min~LV_max)
                              #endif
 715   2              }       
 716   1              pData[5] = (BYTE)GainPos; 
 717   1              pData[6] = (BYTE)GainNeg;
 718   1          // D-Domain Peaking 
 719   1              CScalerPageSelect(_PAGE7);
 720   1              CScalerWrite(_P7_PEAKING_DATA00_AA, 11, pData, _AUTOINC);
 721   1              #if(_HDMI_SUPPORT == _OFF)
                      //if(_GET_INPUT_SOURCE()==_SOURCE_DVI)//HDMI Source & input DVI timing
                      #elif(_HDMI_SUPPORT == _ON || _TMDS_SUPPORT == _ON)
 724   1              if(_GET_INPUT_SOURCE()==_SOURCE_DVI || (_GET_INPUT_SOURCE() == _SOURCE_HDMI && !CHdmiFormatDetect()))//HD
             -MI Source & input DVI timing
 725   1                      CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, 0x00);             // disable Peaking and Coring
 726   1              else
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 13  

 727   1              #endif
 728   1          {
 729   2              if (bSourceVideo())
 730   2              {
 731   3                      CScalerSetByte(_P7_DLTI_DCTI_ENABLE_A1, 0xC0);       //Open  D DOMAIN's DCTI, Open GAIN to 0xOF
 732   3                      CScalerSetByte(_P7_DLTI_GAIN_A3, 0x05);              //DLTi_Gain
 733   3                      CScalerSetByte(_P7_DLTI_GAIN_THRESHOLD_A4, 0x01);        //DLTi_Gain_Threshold   0x1e
 734   3                      CScalerSetByte(_P7_DLTI_OPTIONS_A5, 0x70);               //DLTi_Options
 735   3                      CScalerSetByte(_P7_DCTI_1ST_GAIN_A6, 0x0F);              //Open GAIN to 0xOF
 736   3                  CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, _BIT3);        // enable Peaking and Coring
 737   3              }
 738   2              else
 739   2              {
 740   3                  CScalerSetBit(_P7_DLTI_DCTI_ENABLE_A1, ~(_BIT6 | _BIT7), 0x00);
 741   3                  CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, _BIT3);        // enable Peaking and Coring
 742   3              }
 743   2          }
 744   1      
 745   1          switch(_GET_INPUT_SOURCE())
 746   1          {
 747   2          case _SOURCE_VGA:
 748   2                      CScalerPageSelect(_PAGE6);
 749   2                      CScalerSetBit(_P6_PEAKING_ENABLE_C1, ~_BIT3, 0x00);     // disable Peaking and Coring
 750   2                      return;
 751   2      
 752   2          case _SOURCE_HDMI:
 753   2          case _SOURCE_DVI:
 754   2                      //if(HDMI_V_Height>=720)                //720p above
 755   2                              pData[0] = 0x00;                                        //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
 756   2                      //else
 757   2                              //pData[0] = 0x00;                                      //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
 758   2                      pData[1] = 0x7E;                                                //Peaking_C0 (126) 
 759   2                      pData[2] = 0xF7;                                                //Peaking_C1 (-19)      
 760   2                      pData[3] = 0x4A;                                                //Peaking_C2 (82)
 761   2                      pData[4] = 0x00;                                                //Gain_Blur
 762   2                      pData[5] = 0x14/*ucPeaking*13*/;                //Gain_Pos(Min~Max)
 763   2                      pData[6] = 0x14/*ucPeaking*13*/;                //Gain_Neg(Min~Max)
 764   2                      pData[7] = 0x0F;                                                //Pos_Range(MSB)+Neg_Range(MSB)
 765   2                      pData[8] = 0xFF;                                                //Pos_Range(LSB)(80)
 766   2                      pData[9] = 0xFF;                                                //Neg_Range(LSB)(80)
 767   2                      pData[10] = 0x09;                                       //Coring(LV_min~LV_max)         
 768   2              break;
 769   2      
 770   2          case _SOURCE_YPBPR:
 771   2                      pData[0] = 0x00;                                        //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels                   
 772   2                      pData[1] = 0x7E;                                                //Peaking_C0 (126) 
 773   2                      pData[2] = 0xF7;                                                //Peaking_C1 (-19)      
 774   2                      pData[3] = 0x4A;                                                //Peaking_C2 (82)
 775   2                      pData[4] = 0x00;                                                //Gain_Blur
 776   2                      pData[5] = 0x14/*ucPeaking*13*/;                //Gain_Pos(Min~Max)
 777   2                      pData[6] = 0x14/*ucPeaking*13*/;                //Gain_Neg(Min~Max)
 778   2                      pData[7] = 0x0F;                                                //Pos_Range(MSB)+Neg_Range(MSB)
 779   2                      pData[8] = 0xFF;                                                //Pos_Range(LSB)(1023)
 780   2                      pData[9] = 0xFF;                                                //Neg_Range(LSB)(1023)
 781   2                      pData[10] = 0x09;                                       //Coring(LV_min~LV_max)                 
 782   2              break;
 783   2      
 784   2          default:   //AV TV SV               
 785   2      #if 1
 786   2                      pData[0] = 0x00; //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels     
 787   2                      pData[1] = 0x7e; //Peaking_C0 (126 
 788   2                      pData[2] = 0xf6; //Peaking_C1 (-10  
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 14  

 789   2                      pData[3] = 0x4b; //Peaking_C2 (75
 790   2                      pData[4] = 0x00; //Gain_Blur
 791   2                      GainPos  = ucPeaking * 4;
 792   2                      GainPos  = GainPos   / 25; //ucPeaking*4;//0x14/*ucPeaking*13*/; //Gain_Pos(Min~Max)
 793   2                      GainNeg  = ucPeaking * 8;
 794   2                      GainNeg  = GainNeg   / 25;
 795   2                      //pData[6] = ucPeaking * 4;//0x14/*ucPeaking*13*/; //Gain_Neg(Min~Max)
 796   2                      pData[7] = 0x00; //Pos_Range(MSB)+Neg_Range(MSB)
 797   2                      pData[8] = 0x1E; //Pos_Range(LSB)(30)
 798   2                      pData[9] = 0x32;  //Neg_Range(LSB)(50)
 799   2                      pData[10] = 0x05;//0xFF;//0x05; //Coring(LV_min~LV_max)
 800   2      #else
                              pData[0] = 0x00;                                            //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels                    
                              pData[1] = 0x7F;                                                //Peaking_C0 
                              pData[2] = 0x4A;                                                //Peaking_C1    
                              pData[3] = 0xF6;                                                //Peaking_C2
                              pData[4] = 0x00;                                                //Gain_Blur
                              pData[5] = (WORD)(ucPeaking*255)/100;   //Gain_Pos(Min~Max)
                              pData[6] = (WORD)(ucPeaking*255)/100;   //Gain_Neg(Min~Max)
                              pData[7] = 0x00;                                                //Pos_Range(MSB)+Neg_Range(MSB)
                              pData[8] = 0x0A;                                                //Pos_Range(LSB)(1023)
                              pData[9] = 0x0A;                                                //Neg_Range(LSB)(1023)
                              pData[10] = 0x07;                                           //Coring(LV_min~LV_max)
              #endif
 813   2              break;
 814   2              }
 815   1                  pData[5] = GainPos;
 816   1                  pData[6] = GainNeg;
 817   1      
 818   1          // I-Domain Peaking 
 819   1              CScalerPageSelect(_PAGE6);
 820   1              CScalerWrite(_P6_PEAKING_DATA00_C2, 11, pData, _AUTOINC);
 821   1              #if(_HDMI_SUPPORT == _OFF)
                      //if(_GET_INPUT_SOURCE()==_SOURCE_DVI)//HDMI Source & input DVI timing
                      #elif(_HDMI_SUPPORT == _ON || _TMDS_SUPPORT == _ON)
 824   1              if(_GET_INPUT_SOURCE()==_SOURCE_DVI || (_GET_INPUT_SOURCE() == _SOURCE_HDMI && !CHdmiFormatDetect()))//HD
             -MI Source & input DVI timing
 825   1                      CScalerSetBit(_P6_PEAKING_ENABLE_C1, ~_BIT3, 0x00);             // disable Peaking and Coring
 826   1              else
 827   1              #endif
 828   1          {
 829   2              if (bSourceVideo())
 830   2              {
 831   3                  CScalerSetByte(_P6_DCTI_1ST_GAIN_D8, 0x0f);  //Close  I DOMAIN's DCTI,Open GAIN to 0xOF
 832   3                  CScalerSetByte(_P6_SPATIAL_CTRL_DB, 0x02);
 833   3                      CScalerSetByte(_P6_PEAKING_ENABLE_C1, 0x00);                // disable Peaking and Coring
 834   3                      CScalerSetBit(_P6_PEAKING_ENABLE_C1, ~_BIT3, _BIT3); // enable Peaking and Coring
 835   3              }
 836   2              else
 837   2              {
 838   3                  CScalerSetByte(_P6_DCTI_1ST_GAIN_D8, 0x4A);
 839   3                  CScalerSetByte(_P6_SPATIAL_CTRL_DB, 0x00);
 840   3                      CScalerSetBit(_P6_PEAKING_ENABLE_C1, ~_BIT3, _BIT3);    // enable Peaking and Coring
 841   3              }
 842   2              }
 843   1      }
 844                  
 845          #else
              
              #if(_Peaking_Coring_Table == SharpnessTable1)
                                                                                                                  
              BYTE code PeakingCoeff[][6] =
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 15  

              {
                      //Peaking_Coef0,  Peaking_Coef1,  Peaking_Coef2,  Coring_Min,  Coring_Max_Pos,  Coring_Max_Neg ,
              
                      //level=1 :
                      0x30, 0xe5, 0x3, 0x5, 0x50, 0xb0,
                      //level=2 :
                      0x38, 0xe1, 0x3, 0x5, 0x50, 0xb0,
                      //level=3 :
                      0x40, 0xdc, 0x4, 0x5, 0x50, 0xb0,
                      //level=4 :
                      0x46, 0xd7, 0x6, 0x5, 0x50, 0xb0,
                      //level=5 :
                      0x4e, 0xd3, 0x6, 0x5, 0x50, 0xb0,
                      //level=6 :
                      0x56, 0xce, 0x7, 0x5, 0x50, 0xb0,
                      //level=7 :
                      0x5e, 0xca, 0x7, 0x5, 0x50, 0xb0,
                      //level=8 :
                      0x66, 0xc5, 0x8, 0x5, 0x50, 0xb0,
                      //level=9 :
                      0x6e, 0xc1, 0x8, 0x5, 0x50, 0xb0,
                      //level=10 :
                      0x76, 0xbc, 0x9, 0x5, 0x50, 0xb0,
                      //level=11 :
                      0x40, 0xdc, 0x4, 0x5, 0x50, 0xb0,
                      //level=12 :
                      0x46, 0xd7, 0x6, 0x5, 0x50, 0xb0,
                      //level=13 :
                      0x4e, 0xd3, 0x6, 0x5, 0x50, 0xb0,
                      //level=14 :
                      0x56, 0xce, 0x7, 0x5, 0x50, 0xb0,
                      //level=15 :
                      0x5e, 0xca, 0x7, 0x5, 0x50, 0xb0,
                      //level=16 :
                      0x66, 0xc5, 0x8, 0x5, 0x50, 0xb0,
              };
              
              BYTE code TVPeakingCoeff[][6] =
              {
                      //Peaking_Coef0,  Peaking_Coef1,  Peaking_Coef2,  Coring_Min,  Coring_Max_Pos,  Coring_Max_Neg ,
              
                      //level=0 :
                      0x0, 0x0, 0x0, 0x14, 0x50, 0xb0,
                      //level=1 :
                      0x4, 0x1, 0xfd, 0x16, 0x50, 0xb0,
                      //level=2 :
                      0x6, 0x2, 0xfb, 0x18, 0x50, 0xb0,
                      //level=3 :
                      0xa, 0x3, 0xf8, 0x1a, 0x50, 0xb0,
                      //level=4 :
                      0xc, 0x5, 0xf5, 0x1c, 0x50, 0xb0,
                      //level=5 :
                      0x10, 0x6, 0xf2, 0x1e, 0x50, 0xb0,
                      //level=6 :
                      0x12, 0x7, 0xf0, 0x1f, 0x50, 0xb0,
                      //level=7 :
                      0x16, 0x8, 0xed, 0x1f, 0x50, 0xb0,
                      //level=8 :
                      0x1a, 0xa, 0xe9, 0x1f, 0x50, 0xb0,
                      //level=9 :
                      0x1c, 0xb, 0xe7, 0x1f, 0x50, 0xb0,
                      //level=10 :
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 16  

                      0x20, 0xc, 0xe4, 0x1f, 0x50, 0xb0,
                      //level=11 :
                      0x22, 0xd, 0xe2, 0x1f, 0x50, 0xb0,
                      //level=12 :
                      0x26, 0xf, 0xde, 0x1f, 0x50, 0xb0,
                      //level=13 :
                      0x2c, 0x11, 0xd9, 0x1f, 0x50, 0xb0,
                      //level=14 :
                      0x32, 0x14, 0xd3, 0x1f, 0x50, 0xb0,
                      //level=15 :
                      0x38, 0x16, 0xce, 0x1f, 0x50, 0xb0,
                      //level=16 :
                      0x3e, 0x19, 0xc8, 0x1f, 0x50, 0xb0,
              };
              
              #elif(_Peaking_Coring_Table == SharpnessTable2)
              
              BYTE code PeakingCoeff[][6] =
              {
                      //Peaking_Coef0,  Peaking_Coef1,  Peaking_Coef2,  Coring_Min,  Coring_Max_Pos,  Coring_Max_Neg ,
              
                      //level=1 :
                      0x08, 0x00, 0xFC, 0x00, 0x28, 0xF8,
                      //level=2 :
                      0x0C, 0x00, 0xFA, 0x00, 0x28, 0xF8,
                      //level=3 :
                      0x10, 0x00, 0xF8, 0x00, 0x28, 0xF8,
                      //level=4 :
                  0x18, 0x00, 0xF4, 0x00, 0x28, 0xF8, //3
                      //level=5 :
                      0x20, 0x00, 0xF0, 0x00, 0x28, 0xF8,
                      //level=6 :
                      0x28, 0x00, 0xEC, 0x00, 0x28, 0xF8,
                      //level=7 :
                      0x30, 0x00, 0xE8, 0x00, 0x28, 0xF8,
                      //level=8 :
                      0x38, 0x00, 0xE4, 0x00, 0x28, 0xF8,
                      //level=9 :
                      0x40, 0x00, 0xE0, 0x00, 0x28, 0xF8,
                      //level=10 :
                      0x46, 0x00, 0xDD, 0x00, 0x28, 0xF8,
                      //level=11 :
                      0x4E, 0x00, 0xD9, 0x00, 0x28, 0xF8,
                      //level=12 :
                      0x56, 0x00, 0xD5, 0x00, 0x28, 0xF8,
                      //level=13 :
                      0x5E, 0x00, 0xD1, 0x00, 0x28, 0xF8,
                      //level=14 :
                      0x66, 0x00, 0xCD, 0x00, 0x28, 0xF8,
                      //level=15 :
                      0x6E, 0x00, 0xC9, 0x00, 0x28, 0xF8,
                      //level=16 :
                      0x76, 0x00, 0xC5, 0x00, 0x28, 0xF8,
              };
              
              BYTE code TVPeakingCoeff[][6] =
              {
                      //Peaking_Coef0,  Peaking_Coef1,  Peaking_Coef2,  Coring_Min,  Coring_Max_Pos,  Coring_Max_Neg ,
              
                      //level=1 :
                       0x08, 0x00, 0xFC, 0x12, 0x60, 0xF8,
                      //level=2 :
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 17  

                       0x0A, 0x00, 0xFB,      0x12, 0x60, 0xF8,
                      //level=3 :
                       0x0C, 0x00, 0xFA,      0x12, 0x60, 0xF8,
                      //level=4 :
                       0x0E, 0x00, 0xF9,      0x12, 0x60, 0xF8,
                      //level=5 :
                       0x10, 0x00, 0xF8,      0x12, 0x60, 0xF8,
                      //level=6 :
                       0x12, 0x00, 0xF7,      0x12, 0x60, 0xF8,
                      //level=7 :
                       0x14, 0x00, 0xF6,      0x12, 0x60, 0xF8,
                      //level=8 :
                       0x16, 0x00, 0xF5,      0x12, 0x60, 0xF8,
                      //level=9 :
                  0x18, 0x00, 0xF4,   0x12, 0x60, 0xF8,
                      //level=10 :
                       0x1A, 0x00, 0xF3,      0x12, 0x60, 0xF8,
                      //level=11 :
                       0x1C, 0x00, 0xF2,      0x12, 0x60, 0xF8,
                      //level=12 :
                       0x1E, 0x00, 0xF1,      0x12, 0x60, 0xF8,
                      //level=13 :
                       0x20, 0x00, 0xF0,      0x12, 0x60, 0xF8,
                      //level=14 :
                       0x22, 0x00, 0xEF,      0x12, 0x60, 0xF8,
                       //level=15 :
                       0x24, 0x00, 0xEE,      0x12, 0x60, 0xF8,
                      //level=16 :
                       0x26, 0x00, 0xED,      0x12, 0x60, 0xF8,
              };
              #endif
              
              //----------------------------------------------------
              // CAdjustPeakingFilter
              // Adjust Peaking Filter and Coring Control
              // @param <Coefficient C0 of Peaking Filter>
              // @return {none}
              //----------------------------------------------------
              
              void CAdjustPeakingFilter(SBYTE ucPeaking)
              {
                      #if (_Peaking_Coring_Table != SharpnessNoneTable)//reference Table
                      if((_GET_INPUT_SOURCE()==_SOURCE_VGA)||(_GET_INPUT_SOURCE()==_SOURCE_DVI) || (_GET_INPUT_SOURCE() == _SOU
             -RCE_HDMI))
                      {
                              CScalerPageSelect(_PAGE7);
                              CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x00);
              
                              return;
                      }
                      else
                      {
                              if(_GET_INPUT_SOURCE() == _SOURCE_VIDEO_TV)
                              {
                                      pData[0] = TVPeakingCoeff[ucPeaking][0];
                                      pData[1] = TVPeakingCoeff[ucPeaking][1];
                                      pData[2] = TVPeakingCoeff[ucPeaking][2];
                                      pData[3] = TVPeakingCoeff[ucPeaking][3];
                                      pData[4] = TVPeakingCoeff[ucPeaking][4];
                                      pData[5] = TVPeakingCoeff[ucPeaking][5];
              
                              }
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 18  

                              else
                              {
                                      pData[0] = PeakingCoeff[ucPeaking][0];
                                      pData[1] = PeakingCoeff[ucPeaking][1];
                                      pData[2] = PeakingCoeff[ucPeaking][2];
                                      pData[3] = PeakingCoeff[ucPeaking][3];
                                      pData[4] = PeakingCoeff[ucPeaking][4];
                                      pData[5] = PeakingCoeff[ucPeaking][5];
                              }
              
                              CScalerPageSelect(_PAGE7);
                              CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x80);
                              CScalerWrite(_P7_PC_DATA_PORT_D7, 6, pData, _NON_AUTOINC);
                              CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x40);
                      }
              
                      #else//default
              
                      if((_GET_INPUT_SOURCE() == _SOURCE_VGA)||(_GET_INPUT_SOURCE() == _SOURCE_DVI) || (_GET_INPUT_SOURCE() == 
             -_SOURCE_HDMI))
                              ucPeaking = ucPeaking * 2;
                      else
                              ucPeaking = ucPeaking * 8;
              
                      if(ucPeaking > 126)
                              ucPeaking = 126;
                      if(ucPeaking < 14 && ucPeaking > 0)
                              ucPeaking = 14;
                              
                      pData[0] = ((ucPeaking +1) >> 1) << 1;
                      if((bit)(ucPeaking & 0x01))
                      {
                              pData[1] = (SWORD)-72 * pData[0] / 126;
                              pData[2] = (SWORD)-(pData[0] + 2*pData[1]) / 2;
                      }
                      else
                      {
                              pData[1] = (SWORD)-73 * pData[0] / 126;
                              pData[2] = (SWORD)-(pData[0] + 2*pData[1]) / 2;
                      }
              
                      pData[3] = (BYTE)_CORING_MIN;
                      pData[4] = (BYTE)_CORING_MAX_POS;
                      pData[5] = (SBYTE)_CORING_MAX_NEG;
                      CScalerPageSelect(_PAGE7);
                      CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x80);
                      CScalerWrite(_P7_PC_DATA_PORT_D7, 6, pData, _NON_AUTOINC);
                      CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x40);
              
                      #endif
              }
              #endif
1086          
1087          //--------------------------------------------------
1088          // Description  : Adjust sharpness
1089          // Input Value  : None
1090          // Output Value : None
1091          //--------------------------------------------------
1092          void CAdjustPeakingCoding(void)
1093          {
1094   1              CAdjustPeakingFilter(GET_PEAKING_CORING());
1095   1      }
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 19  

1096          
1097          //--------------------------------------------------
1098          // Description  : Adjust backlight
1099          // Input Value  : None
1100          // Output Value : None
1101          //--------------------------------------------------
1102          void CAdjustBacklight(void)
1103          {
1104   1          BYTE ucLight = 0;
1105   1      
1106   1              if (GET_LIGHTPOWERSTATUS())
1107   1                      stSystemData.BackLight = stConBriData.Brightness;//GET_BRIGHTNESS();
1108   1              else
1109   1                      stSystemData.BackLight = 0;
1110   1      
1111   1          ucLight = (WORD)(_BACKLIGHT_MAX - _BACKLIGHT_MIN) * stSystemData.BackLight/100;
1112   1      
1113   1              #if(_BACKLIGHT_PWM_INVERSE == _ENABLE)
                  ucLight = _BACKLIGHT_MAX - ucLight;
                      #else
1116   1          ucLight = _BACKLIGHT_MIN + ucLight;
1117   1              #endif
1118   1      
1119   1          CSetPWM(_BACKLIGHT_PWM, ucLight);
1120   1      }
1121          
1122          
1123          
1124          #if(sRGB_Color_Enhance == _ENABLE)
1125          //Use sRGB to adjust Saturation and Hue
1126          void CAdjustSaturationHue(BYTE  ucValue, BOOL bSaturationIndex)
1127          {
1128   1      //Lewis, this table have multiplied by 1024
1129   1              INT16 code YUV2RGB[3][3] =
1130   1              {
1131   1                {1024,   0,      1436},
1132   1                {1024,   -342,   -731},
1133   1                {1024,   1815,   0}
1134   1               };
1135   1      
1136   1      //Lewis, this table have multiplied by 1024
1137   1              INT16 code RGB2YUV[3][3] =
1138   1              {
1139   1                  {306,     601,   117},
1140   1                {-173,   -339,    512},
1141   1                  {512,   -429,   -83}
1142   1               };
1143   1      
1144   1              BYTE i, j;
1145   1              INT16 temp_buff0[3][3];
1146   1              //731401***
1147   1              //INT16 temp_buff1[3][3];
1148   1              //INT16 temp_buff2[3][3];
1149   1              INT16 MATRIX_GAIN_HUE[3][3];
1150   1              //INT16 MATRIX_GAIN[3][3];
1151   1              //INT16 MATRIX_HUE[3][3];
1152   1              //731401###
1153   1              INT16 temp_hue, temp_saturation;
1154   1      
1155   1              if(bSaturationIndex == _TRUE) //adjust saturation
1156   1              {
1157   2                      temp_saturation=(INT16)ucValue;
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 20  

1158   2                      temp_hue=(INT16)GET_HUE() - 50;
1159   2              }
1160   1              else
1161   1              {
1162   2                      temp_saturation = (INT16)GET_SATURATION();
1163   2                      temp_hue=(INT16)ucValue - 50;
1164   2              }
1165   1      
1166   1              //Lewis 20060717, to prevent adjust CSC matrix, the saturation overflow
1167   1              if(temp_saturation>75)
1168   1                      temp_saturation = 75;
1169   1              else if(temp_saturation<25)
1170   1                      temp_saturation = 25;
1171   1      
1172   1              temp_hue = temp_hue*19>>5; //Lewis, 20060720, limited Hue range to prevent grey bar have color
1173   1      //731401***
1174   1      //Lewis, this table have multiplied by 1024
1175   1              MATRIX_GAIN_HUE[0][0] = 1024;
1176   1              MATRIX_GAIN_HUE[0][1] = 0;
1177   1              MATRIX_GAIN_HUE[0][2] = 0;
1178   1              MATRIX_GAIN_HUE[1][0] = 0;
1179   1              MATRIX_GAIN_HUE[1][1] = ((temp_saturation<<7)/25)<<2;
1180   1              MATRIX_GAIN_HUE[1][2] = 0;
1181   1              MATRIX_GAIN_HUE[2][0] = 0;
1182   1              MATRIX_GAIN_HUE[2][1] = 0;
1183   1              MATRIX_GAIN_HUE[2][2] = MATRIX_GAIN_HUE[1][1];
1184   1      
1185   1              CAdjustMatrixMultiply(MATRIX_GAIN_HUE,RGB2YUV,temp_buff0);
1186   1              
1187   1      //Lewis, this table have multiplied by 1024
1188   1              MATRIX_GAIN_HUE[0][0] = 1024;
1189   1              MATRIX_GAIN_HUE[0][1] = 0;
1190   1              MATRIX_GAIN_HUE[0][2] = 0;
1191   1              MATRIX_GAIN_HUE[1][0] = 0;
1192   1              MATRIX_GAIN_HUE[1][1] = CAdjustCosine(temp_hue);
1193   1              MATRIX_GAIN_HUE[1][2] = CAdjustSine(temp_hue);
1194   1              MATRIX_GAIN_HUE[2][0] = 0;
1195   1              MATRIX_GAIN_HUE[2][1] = (-1)*MATRIX_GAIN_HUE[1][2];//-CAdjustSine(temp);
1196   1              MATRIX_GAIN_HUE[2][2] = MATRIX_GAIN_HUE[1][1]; //CAdjustCosine(temp);
1197   1      
1198   1              CAdjustMatrixMultiply(MATRIX_GAIN_HUE,temp_buff0,temp_buff0);
1199   1              CAdjustMatrixMultiply(YUV2RGB,temp_buff0,temp_buff0);
1200   1      
1201   1              for(i=0; i<3; i++)
1202   1          {
1203   2                      for(j=0; j<3; j++)
1204   2              {
1205   3                      if (i==j)
1206   3                         temp_buff0[i][j]-=1024;
1207   3          
1208   3                      temp_buff0[i][j] = temp_buff0[i][j]>>1;
1209   3          
1210   3                      if (temp_buff0[i][j]>255)
1211   3                              temp_buff0[i][j] = 255;
1212   3                      else if(temp_buff0[i][j]<-256)
1213   3                              temp_buff0[i][j] = -256;
1214   3              }
1215   2          }
1216   1      
1217   1              //Write R
1218   1              //frank CScalerSetBit(_COLOR_CTRL_62,0xc7,0x08);
1219   1              pData[0] =(temp_buff0[0][0]<0?1:0);
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 21  

1220   1              pData[1]=(BYTE)(temp_buff0[0][0]);
1221   1              pData[2] =(temp_buff0[0][1]<0?1:0);
1222   1              pData[3]=(BYTE)(temp_buff0[0][1]);
1223   1              pData[4] =(temp_buff0[0][2]<0?1:0);
1224   1              pData[5]=(BYTE)(temp_buff0[0][2]);
1225   1      
1226   1      //      CAdjustSetsRGBRhue();
1227   1              CAdjustSetYpbprRhue();
1228   1      
1229   1              //Write G
1230   1              //frank CScalerSetBit(_COLOR_CTRL_62,0xc7,0x10);
1231   1      
1232   1              pData[0] =(temp_buff0[1][0]<0?1:0);
1233   1              pData[1]=(BYTE)(temp_buff0[1][0]);
1234   1              pData[2] =(temp_buff0[1][1]<0?1:0);
1235   1              pData[3]=(BYTE)(temp_buff0[1][1]);
1236   1              pData[4] =(temp_buff0[1][2]<0?1:0);
1237   1              pData[5]=(BYTE)(temp_buff0[1][2]);
1238   1      
1239   1      //      CAdjustSetsRGBGhue();
1240   1              CAdjustSetYpbprGhue();
1241   1      
1242   1              //Write B
1243   1      
1244   1              pData[0] =(temp_buff0[2][0]<0?1:0);
1245   1              pData[1]=(BYTE)(temp_buff0[2][0]);
1246   1              pData[2] =(temp_buff0[2][1]<0?1:0);
1247   1              pData[3]=(BYTE)(temp_buff0[2][1]);
1248   1              pData[4] =(temp_buff0[2][2]<0?1:0);
1249   1              pData[5]=(BYTE)(temp_buff0[2][2]);
1250   1      //731401###
1251   1      //      CAdjustSetsRGBBhue();
1252   1              CAdjustSetYpbprBhue();
1253   1      
1254   1              CScalerSetBit(_COLOR_CTRL_62, ~(_BIT7), _BIT7);                 // cftsai 20061031 added, ready to write
1255   1      }
1256          
1257          INT16 CAdjustCosine(INT16 fDegree)
1258          {
1259   1              //Lewis, the curve value table have multiplied by 1024
1260   1              UINT16 code fCosCurveAngle[13] = {   0,   6,  12,  18,  24,  30,  37,  44,  52,  60,  68,  78, 90};
1261   1              UINT16 code fCosCurveValue[13] = {1024, 1018, 1002, 974, 935, 887, 818, 737, 630, 512, 384, 213,  0};
1262   1              UINT8 i,cQuadrant;
1263   1              INT16 fDegreeTemp, fDegreeSpan, fCosValueSpan, fCosValue;
1264   1      
1265   1              if (fDegree < 0)
1266   1                      fDegree += 360;
1267   1      
1268   1              fDegree = fDegree%360;
1269   1      
1270   1              //locate degree on which quadrant
1271   1              cQuadrant = (UINT8)(fDegree / 90);
1272   1              cQuadrant++;
1273   1              if (cQuadrant==1) //first quadrant
1274   1                      fDegree = fDegree;
1275   1              else if(cQuadrant==2) //second quadrant
1276   1                      fDegree = 180 - fDegree;
1277   1              else if(cQuadrant==3) //third quadrant
1278   1                      fDegree = fDegree - 180;
1279   1              else if(cQuadrant==4) //forth quadrant
1280   1                      fDegree = 360 -fDegree;
1281   1              //locate degree on which quadrant
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 22  

1282   1      
1283   1              if (fDegree<=fCosCurveAngle[0])
1284   1                      fCosValue = fCosCurveValue[0];
1285   1              else
1286   1              {
1287   2                      for (i=0;fCosCurveAngle[i] < fDegree; i++);
1288   2      
1289   2                      i--;
1290   2                      fDegreeTemp = fDegree-fCosCurveAngle[i];
1291   2                      fDegreeSpan = fCosCurveAngle[i+1]-fCosCurveAngle[i];
1292   2                      fCosValueSpan = fCosCurveValue[i+1]-fCosCurveValue[i];
1293   2                      fCosValue = fCosCurveValue[i]+fDegreeTemp*fCosValueSpan/fDegreeSpan;
1294   2              }
1295   1      
1296   1              if (cQuadrant==2 || cQuadrant==3)
1297   1                      fCosValue = fCosValue*(-1);
1298   1      
1299   1              return fCosValue;
1300   1      }
1301          
1302          INT16 CAdjustSine(INT16 fDegree)
1303          {
1304   1              //Lewis, this table have multiplied by 1024
1305   1              UINT16 code fSinCurveAngle[13] = {0,   6,  12,  18,  24,  30,  37,  44,  52,  60,  68,  78, 90};
1306   1              UINT16 code fSinCurveValue[13] = {0, 107, 213, 316, 416, 512, 616, 711, 807, 887, 949, 1002,  1024};
1307   1              UINT8 i,cQuadrant;
1308   1              INT16 fDegreeTemp,fDegreeSpan,fSinValueSpan,fSinValue;
1309   1      
1310   1              if (fDegree < 0)
1311   1                      fDegree += 360;
1312   1      
1313   1              fDegree = fDegree%360;
1314   1      
1315   1              //locate degree on which quadrant
1316   1              cQuadrant = (UINT8)(fDegree / 90);
1317   1              cQuadrant++;
1318   1              if (cQuadrant==1) //first quadrant
1319   1                      fDegree = fDegree;
1320   1              else if(cQuadrant==2) //second quadrant
1321   1                      fDegree = 180 - fDegree;
1322   1              else if(cQuadrant==3) //third quadrant
1323   1                      fDegree = fDegree - 180;
1324   1              else if(cQuadrant==4) //forth quadrant
1325   1                      fDegree = 360 -fDegree;
1326   1              //locate degree on which quadrant
1327   1      
1328   1              if (fDegree<=fSinCurveAngle[0])
1329   1                      fSinValue = fSinCurveValue[0];
1330   1              else
1331   1              {
1332   2                      for (i=0;fSinCurveAngle[i] < fDegree; i++);
1333   2      
1334   2                      i--;
1335   2                      fDegreeTemp = fDegree-fSinCurveAngle[i];
1336   2                      fDegreeSpan = fSinCurveAngle[i+1]-fSinCurveAngle[i];
1337   2                      fSinValueSpan = fSinCurveValue[i+1]-fSinCurveValue[i];
1338   2                      fSinValue = fSinCurveValue[i]+fDegreeTemp*fSinValueSpan/fDegreeSpan;
1339   2              }
1340   1      
1341   1              if (cQuadrant==3 || cQuadrant==4)
1342   1                      fSinValue = fSinValue*(-1);
1343   1      
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 23  

1344   1              return fSinValue;
1345   1      }
1346          
1347          void CAdjustMatrixMultiply(INT16 (*arrayA)[3], INT16 (*arrayB)[3], INT16 (*arrayC)[3])
1348          {
1349   1              BYTE i, j;
1350   1              INT32 Temp[3][3];
1351   1      
1352   1              for(i=0; i<3; i++)
1353   1              {
1354   2                      for(j=0; j<3; j++)
1355   2                      {
1356   3                              Temp[i][j] = ((INT32)arrayA[i][0]*arrayB[0][j]>>2)
1357   3                                                      + ((INT32)arrayA[i][1]*arrayB[1][j]>>2)
1358   3                                                      + ((INT32)arrayA[i][2]*arrayB[2][j]>>2);
1359   3      
1360   3                              //arrayC[i][j] = (INT16)(Temp[i][j]>>8);//731401
1361   3                      }
1362   2              }
1363   1      
1364   1              for(i=0; i<3; i++)
1365   1              {
1366   2                      for(j=0; j<3; j++)
1367   2                      {
1368   3                              arrayC[i][j] = (INT16)(Temp[i][j]>>8);
1369   3                      }
1370   2              }
1371   1      
1372   1      }
1373          #endif
1374          
1375          BYTE code SatPlus[8]  = { 41, 44, 43, 39, 31, 22, 11, 0 }; // by 1/256
1376          BYTE code SatMinus[8] = { 24, 35, 40, 41, 36, 28, 16, 0 }; // by 1/256
1377          
1378          int CAdjustColorGammaCal(BYTE color, BYTE n) // n = 1~8
1379          {
1380   1              BYTE temp;
1381   1      
1382   1              if (color == 0)         //R
1383   1                      temp = GET_ICM_SAT_R();
1384   1              else if (color== 1)     //G
1385   1                      temp = GET_ICM_SAT_G();
1386   1              else if (color == 2)//B
1387   1                      temp = GET_ICM_SAT_B();
1388   1              else if (color == 3)//Y
1389   1                      temp = GET_ICM_SAT_Y();
1390   1              else if (color == 4)//C
1391   1                      temp = GET_ICM_SAT_C();
1392   1          temp *= 2;  //Since the scale for OSD(from 0~16) and cloor(from 0~32) is different, we will have to mu
             -ltiply
1393   1                                 //temp by 2 to make up the difference
1394   1          if (temp >= 16)
1395   1          {
1396   2                      return ((int)(512*n) + (int)((temp-16)*(int)SatPlus[n-1])) / 64 ;
1397   2          }
1398   1          else
1399   1          {
1400   2                      return ((int)(512*n) - (int)((16-temp)*(int)SatMinus[n-1])) / 64 ;
1401   2          }
1402   1      }
1403          
1404          #define CENTER    0x00
C51 COMPILER V7.20   ADJUST_CUSTOMER                                                       10/05/2015 09:30:05 PAGE 24  

1405          #define RIGHT     0x10
1406          #define LEFT      0x20
1407          
1408          void CAdjustMZHueSat(BYTE color)
1409          {
1410   1              //Value  0~4095 => angle 0~359
1411   1              //R / G / B / Y /C
1412   1              //range  256 => 22.5  degree
1413   1              //buffer 128 => 11.25 degree
1414   1              //R / G / B
1415   1              //range  512 => 45    degree
1416   1              //buffer 128 => 11.25 degree
1417   1              CTimerWaitForEvent(_EVENT_DEN_STOP);
1418   1              CAdjustSetHueUVDelta(color, CENTER);
1419   1              CAdjustSetHueUVDelta(color, RIGHT);
1420   1              CAdjustSetHueUVDelta(color, LEFT);
1421   1      
1422   1              CScalerPageSelect(_PAGE7);
1423   1              CScalerSetBit(_P7_ICM_CTRL_D0, ~_BIT7, _BIT7);
1424   1      }
1425          
1426          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4073    ----
   CONSTANT SIZE    =    156    ----
   XDATA SIZE       =   ----     139
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
