C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 1   


C51 COMPILER V7.20, COMPILATION OF MODULE SYNC
OBJECT MODULE PLACED IN .\Output\Sync.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Core\code\Sync.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Output\Sync.lst) OBJECT(.\Output\Sync.obj)

line level    source

   1          //----------------------------------------------------------------------------------------------------
   2          // ID Code      : Sync.c No.0003
   3          // Update Note  :
   4          //
   5          //----------------------------------------------------------------------------------------------------
   6          
   7          #define __SYNC__
   8          
   9          #include "Core\Header\Include.h"
  10          
  11          
  12          /**
  13          * CSyncProcess
  14          * For VGA, DVI or YPbPr input source's state machine process.
  15          * first system initial, then main loop
  16          * @param <none>
  17          * @return {none}
  18          *
  19          */
  20          //--------------------------------------------------
  21          // Description  : For VGA, DVI or YPbPr input source's state machine process.
  22          // Input Value  : None
  23          // Output Value : None
  24          //--------------------------------------------------
  25          void CSyncProcess(void)
  26          {         
  27   1      // Eric 0618
  28   1              #if (_HDMI_SUPPORT == _ON)
  29   1              #if(_HDMI_HOT_PLUG_OPTION)
                  if (GET_POWERSTATUS())
                  {
                      if (bHDMICONNECT)
                              bHot_Plug = _HOT_PLUG_HI;
                      else
                              bHot_Plug = _HOT_PLUG_LOW;
                  }
                      #endif
  38   1              #endif
  39   1      
  40   1              switch (ucCurrState) 
  41   1              {       
  42   2              case _SEARCH_STATE:
  43   2      
  44   2                      if (CSyncHandler())
  45   2                      {
  46   3                              // Source and sync OK
  47   3                              if (CModeDetect()) 
  48   3                              {
  49   4                                      if (stModeInfo.ModeCurr == _MODE_NOSIGNAL)
  50   4                                      {
  51   5                                              #if(_HDMI_HOT_PLUG_OPTION)
                                  bDVIDetect = 0;
                                                      #endif
  54   5      
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 2   

  55   5                                              ucCurrState = _NOSIGNAL_STATE;
  56   5                                              #if (_HDMI_SUPPORT == _ON)
  57   5                                              if( CHdmiFormatDetect()
  58   5                                              && ((_GET_INPUT_SOURCE() == _SOURCE_DVI) || (_GET_INPUT_SOURCE() == _SOURCE_HDMI))
  59   5                                              && ((ucHdmiTimerEvent == 0) || (ucHdmiTimerEvent == _INACTIVE_COUNTDOWN_EVENT)) )//741001
  60   5                                                      ucHdmiTimerEvent = _HDMI_NO_SIGNAL_CHECK_CNT;//741001
  61   5                                              #endif
  62   5      
  63   5                                      //      SET_READYFORDISPLAY();
  64   5                                      }
  65   4                                      else if (stModeInfo.ModeCurr == _MODE_NOSUPPORT)
  66   4                                      {
  67   5                                              #if(_HDMI_HOT_PLUG_OPTION)
                                  bDVIDetect = 0;
                                                      #endif
  70   5      
  71   5                                              CModeAutoMeasureOn();
  72   5                                              ucCurrState = _NOSUPPORT_STATE;
  73   5                                      }
  74   4                                      else            //make sure input soure OK and display mode
  75   4                                      {
  76   5                                              #if(_HDMI_SUPPORT == _ON && _HDMI_HOT_PLUG_OPTION == _ENABLE)
                                                      if(!CHdmiFormatDetect() && (_GET_INPUT_SOURCE() == _SOURCE_HDMI) && bDVIDetect == 0)
                                  {              
                                      bDVIDetect = 1;
                                      bHot_Plug = _HOT_PLUG_LOW;
                                      CTimerDelayXms(300);
                                      bHot_Plug = _HOT_PLUG_HI;
                                      CModeResetMode();
                                      return;
                                  }
                                      #endif
  87   5      
  88   5                                              #if(_OSD_TYPE == _OSD003)
  89   5                                      #if(_CHANGE_SOURCE_METHOD == _CHANGE_SOURCE_METHOD_0)
  90   5                          if ((ucOsdState < _MI_SOURCE_VGA || ucOsdState > _MI_SOURCE_TV) && _GET_INPUT_SOURCE()
             - != _SOURCE_HDMI)
  91   5                                      #else
                                      if(_GET_INPUT_SOURCE() != _SOURCE_HDMI)
                                              #endif
  94   5                                              #else
                                      if(_GET_INPUT_SOURCE() != _SOURCE_HDMI)
                                                      #endif
  97   5                              CPowerLightPowerOff();
  98   5      
  99   5                          bShowOSDCurr = (bit)(CScalerGetBit(_OVERLAY_CTRL_6C, _BIT0));
 100   5                          CScalerSetBit(_OVERLAY_CTRL_6C, ~_BIT0, 0x00);
 101   5                                              if(!CModeDisplayActiveMode())
 102   5                                              {
 103   6                                                      CModeResetMode();
 104   6                                                      break;
 105   6                                              }
 106   5                          CScalerSetBit(_OVERLAY_CTRL_6C, ~_BIT0, bShowOSDCurr);
 107   5                          
 108   5                                              CModeAutoMeasureOn();
 109   5      
 110   5                                              #if(_HDMI_SUPPORT == _ON)
 111   5                                              if( CHdmiFormatDetect()
 112   5                                              && ((_GET_INPUT_SOURCE() == _SOURCE_DVI) || (_GET_INPUT_SOURCE() == _SOURCE_HDMI)) )            //Input source 
             -is the HDMI format.
 113   5                                              {
 114   6                              CLR_LIGHTPOWERSTATUS();
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 3   

 115   6                                                      CHdmiAudioFirstTracking();
 116   6                                                      CTimerReactiveTimerEvent(SEC(0.1), CHdmiAudioWaitingFlagReadyEven);
 117   6                                                      ucHdmiTimerEvent = _HDMI_CHECK_CNT;
 118   6                                              }
 119   5                                              else
 120   5                                              {                                                       
 121   6                                              //      SET_READYFORDISPLAY();
 122   6                                              }
 123   5                                              #else
                                              //      SET_READYFORDISPLAY();
                                                      #endif
 126   5      
 127   5                                              SET_READYFORDISPLAY();
 128   5                                              CTimerCancelTimerEvent(CModeNoSignalEvent);
 129   5                                              CTimerCancelTimerEvent(CModeNoCableEvent);
 130   5                                              CTimerCancelTimerEvent(CModeNoSupportEvent);
 131   5                                              CTimerCancelTimerEvent(CModePowerSavingEvent);
 132   5      
 133   5                                              ucCurrState = _ACTIVE_STATE;                            
 134   5                                      }
 135   4      
 136   4                                      SET_READYFORDISPLAY();
 137   4                              }
 138   3                              else
 139   3                              {
 140   4                                      #if(_HDMI_SUPPORT == _ON)
 141   4                                      if (CHdmiFormatDetect() && (_GET_INPUT_SOURCE() == _SOURCE_DVI || _GET_INPUT_SOURCE() == _SOURCE_HDMI)
             -)//for Philips DVD
 142   4                                              CTimerDelayXms(50);//for Philips DVD
 143   4                      #endif
 144   4                              }                                             
 145   3                              ucTimerEvent = _INACTIVE_COUNTDOWN_EVENT;
 146   3                      }
 147   2                      else 
 148   2                      {
 149   3                              #if(_HDMI_SUPPORT == _ON)
 150   3                              if(_GET_INPUT_SOURCE() == _SOURCE_DVI || _GET_INPUT_SOURCE() == _SOURCE_HDMI)
 151   3                                      CTimerCountDownEventProc(&ucTimerEvent, 40,     CModeSyncTimeoutCountDownEvent);        
 152   3                              else
 153   3                                      CTimerCountDownEventProc(&ucTimerEvent, 5,      CModeSyncTimeoutCountDownEvent);
 154   3                              #else
                                              CTimerCountDownEventProc(&ucTimerEvent, 5,      CModeSyncTimeoutCountDownEvent);                                        
                                      #endif
 157   3                      }
 158   2                      break;
 159   2      
 160   2              case _ACTIVE_STATE:
 161   2      
 162   2                      // For VGA, DVI, input*/
 163   2                      if (CFrameSyncDetect())
 164   2                      {
 165   3                              #if(_HDMI_HOT_PLUG_OPTION)
                          bDVIDetect = 0;
                                      #endif
 168   3      
 169   3                              //fram sync unstable
 170   3                              CModeResetMode();
 171   3                              break;
 172   3                      }
 173   2                      else
 174   2                      {
 175   3                              #if (_HDMI_HOT_PLUG_OPTION == _ENABLE)  
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 4   

                              //eric 20070326 philips DVD player
                                              //CModeHDMIStableConfirm();
                                      #endif
 179   3              
 180   3                      if(CModeIsChange())
 181   3                              {               
 182   4                                      #if(_HDMI_HOT_PLUG_OPTION)
                                          bDVIDetect = 0;
                                              #endif
 185   4      
 186   4                      if(_GET_INPUT_SOURCE() == _SOURCE_YPBPR)
 187   4                         CMuteOn();
 188   4                              
 189   4                                      #if (_HDMI_HOT_PLUG_OPTION == _ENABLE)
                                                      //CModeHDMIChageDelay();
                                              #endif
 192   4              
 193   4                                      CModeResetMode();
 194   4                                      break;
 195   4                  }
 196   3                  else
 197   3                              {
 198   4                                      #if(_HDMI_SUPPORT == _ON)
 199   4                                      if((_GET_INPUT_SOURCE() == _SOURCE_DVI) || (_GET_INPUT_SOURCE() == _SOURCE_HDMI))
 200   4                                      {
 201   5                              if(CHdmiFormatDetect())         //Input source is the HDMI format.
 202   5                              {
 203   6                                      if(!GET_HDMIINPUT()) 
 204   6                                                      {       
 205   7                                              CModeResetMode();       
 206   7                                                              break;
 207   7                                      }
 208   6                                      else
 209   6                                                      {
 210   7                                              //if(GET_AUDIOWAITINGTIMEOUT())  // Eric Lee mark for hdmi audio delay output
 211   7                                                      CHdmiEnableAudioOutput();
 212   7                                      }
 213   6                              }
 214   5                              else
 215   5                                              {
 216   6                                      if(GET_HDMIINPUT())
 217   6                                                      {
 218   7                                              CModeResetMode();                       
 219   7                                                              break;
 220   7                              }
 221   6                              }
 222   5                                      }
 223   4                                      #endif
 224   4      
 225   4                      CSetModeReady();
 226   4                      }
 227   3                      }
 228   2      
 229   2                      break;
 230   2                      
 231   2              case _NOSUPPORT_STATE:
 232   2      
 233   2                      if (GET_READYFORDISPLAY() == _TRUE) 
 234   2                      {
 235   3                              CLR_READYFORDISPLAY();
 236   3                  SET_OSD_READYFORDISPLAY(); 
 237   3                              CModeSetFreeRun();
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 5   

 238   3                      //      CAdjustBackgroundColor(0xff, 0x00, 0x00);
 239   3                      }
 240   2                      if (CModeConnectIsChange() || CModeIsChange())
 241   2                              CModeResetMode();
 242   2                      break;
 243   2                      
 244   2              case _NOSIGNAL_STATE: 
 245   2      
 246   2                      #if (_HDMI_HOT_PLUG_OPTION == _ENABLE)  
                              if(GET_READYFORDISPLAY())
                              {
                                      if (_GET_INPUT_SOURCE() == _SOURCE_HDMI) 
                                      {
                              CLR_READYFORDISPLAY();
                                              CModeHdmiHP();
                                      }
                              }
                              #endif
 256   2      
 257   2                      if (!GET_SHOW_NO_SIGNAL()) 
 258   2                      {
 259   3                              SET_SHOW_NO_SIGNAL();
 260   3                              CModeSetFreeRun();
 261   3                  SET_OSD_READYFORDISPLAY();
 262   3              }   
 263   2                                                 
 264   2                      ucInputSyncType = _NO_SYNC_STATE;
 265   2                      CLR_MODESTABLE();
 266   2              //      ucCurrState = _SEARCH_STATE;
 267   2              
 268   2                      if ((CModeConnectIsChange() || CSourceHandler()) && !bSourceVideo())
 269   2                      {
 270   3                              CPowerLedOn();
 271   3                              CModeResetMode();
 272   3                      }
 273   2                      break;
 274   2      
 275   2              case _SLEEP_STATE:
 276   2      
 277   2                      if ((CModeConnectIsChange() || CSourceHandler()) && !bSourceVideo())
 278   2                      {
 279   3                              CPowerLedOn();
 280   3                              CModeResetMode();
 281   3                      }
 282   2                      break;
 283   2      
 284   2              default:
 285   2                      break;
 286   2              }
 287   1      }
 288          
 289          //--------------------------------------------------
 290          void CSetModeReady(void)
 291          {
 292   1      #if (_HDMI_SUPPORT == _ON)
 293   1      
 294   1              if(CHdmiFormatDetect() && (_GET_INPUT_SOURCE()==_SOURCE_DVI || _GET_INPUT_SOURCE() == _SOURCE_HDMI))
 295   1              {                       
 296   2                      if (GET_READYFORDISPLAY() == _TRUE) 
 297   2                      {
 298   3                  CPowerPanelOn();
 299   3      
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 6   

 300   3                      if (GET_LIGHTPOWERSTATUS() == _OFF) 
 301   3                      {
 302   4                      CPowerLightPowerOn();
 303   4                      SET_OSD_READYFORDISPLAY(); 
 304   4                      }
 305   3      
 306   3                      if(ucHdmiTimerEvent == _HDMI_CHECK_CNT)
 307   3                      {
 308   4                      //CScalerSetBit(_VDISP_CTRL_28, ~(_BIT5), (0x00));
 309   4                              //CLR_READYFORDISPLAY();
 310   4                              CLR_SOURCE_AUTOCHANGE();
 311   4                              CScalerPageSelect(_PAGE2);
 312   4                              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_VWDSR_41, ~_BIT0, _BIT0);//Enable packet vari
             -ation Watch Dog
 313   4                              CAdjustEnableWatchDog(_WD_DV_TIMEOUT|_WD_FRAMESYNC);                    
 314   4                              ucHdmiTimerEvent--;
 315   4          
 316   4                     // if (GET_FIRST_SHOW_NOTE())
 317   4                     //    ucOsdEventMsg = _DO_SHOW_NOTE;                     
 318   4                      }
 319   3                      else if(ucHdmiTimerEvent == 0)
 320   3                      {
 321   4                              CModeHDMITimeoutCountDownEvent();
 322   4                              ucHdmiTimerEvent =_INACTIVE_COUNTDOWN_EVENT;
 323   4                      }
 324   3                      else if(ucHdmiTimerEvent ==_INACTIVE_COUNTDOWN_EVENT)
 325   3                      {
 326   4                              return;
 327   4                      }                                       
 328   3                      else
 329   3                      {
 330   4                              ucHdmiTimerEvent--;
 331   4                              CTimerDelayXms(50);
 332   4                      }
 333   3                  }
 334   2              }                       
 335   1              else
 336   1              {
 337   2                      if (GET_READYFORDISPLAY() == _TRUE) 
 338   2                      {
 339   3                  CScalerSetBit(_VDISP_CTRL_28, ~(_BIT5), 0x00);
 340   3                              CLR_READYFORDISPLAY();
 341   3                              CLR_SOURCE_AUTOCHANGE();
 342   3      
 343   3                              #if(_OD_SUPPORT == _ON)
                                      CMemorySetODCompress();
                                      CMemorySetODFIFO();
                                      CMemorySetODOnOff(_ON);
                                      #endif
 348   3      
 349   3                  //080324
 350   3                              if((_GET_INPUT_SOURCE() == _SOURCE_VGA))// || (_GET_INPUT_SOURCE() == _SOURCE_YPBPR))
 351   3                              {
 352   4                              CAdjustAdcClock(stModeUserData.Clock, 1);
 353   4                              CAdjustAdcClock(stModeUserData.Clock, 2);
 354   4                              }
 355   3                      
 356   3                  CPowerPanelOn();
 357   3      
 358   3                              if (GET_LIGHTPOWERSTATUS() == _OFF) 
 359   3                              {
 360   4                      CPowerLightPowerOn();
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 7   

 361   4                              }
 362   3                      
 363   3                              #if (_YPBPR_NONE_CHECK_APLL)
 364   3                              if(_GET_INPUT_SOURCE() == _SOURCE_YPBPR)
 365   3                      CAdjustDisableWatchDog(_WD_ALL);                        // Disable watch dog
 366   3                                      //CAdjustEnableWatchDog(_WD_DV_TIMEOUT | _WD_FRAMESYNC);        // not to watch APLL mis-Lock,hill 20070417
 367   3                              else
 368   3                              #endif          
 369   3      
 370   3                  if (bCNoCheckSyncMode())
 371   3                      CAdjustDisableWatchDog(_WD_ALL);                        // Disable watch dog
 372   3                  else if (_GET_INPUT_SOURCE()==_SOURCE_VGA)
 373   3                                  CAdjustEnableWatchDog(_WD_DV_TIMEOUT | _WD_FRAMESYNC);      // not to watch APLL mis-Lock,hill 20070417
 374   3                  else
 375   3                                      CAdjustEnableWatchDog(_WD_ALL);
 376   3                              
 377   3                  SET_OSD_READYFORDISPLAY(); 
 378   3      
 379   3                  //if (GET_FIRST_SHOW_NOTE())
 380   3                  //   ucOsdEventMsg = _DO_SHOW_NOTE;
 381   3      
 382   3                      }
 383   2                      if ((stModeUserData.FirstAuto == 0) &&   ///!do auto config when go to vga first time
 384   2                              (_GET_INPUT_SOURCE() == _SOURCE_VGA)) 
 385   2                      {
 386   3                              stModeUserData.FirstAuto = 1;
 387   3                  ucOsdEventMsg = _DO_AUTO_CONFIG;
 388   3                      }
 389   2              }
 390   1      
 391   1      #else
              
                      if (GET_READYFORDISPLAY() == _TRUE) 
                      {
                      CScalerSetBit(_VDISP_CTRL_28, ~(_BIT5), (0x00));
                              CLR_READYFORDISPLAY();
                              CLR_SOURCE_AUTOCHANGE();
              
                              #if(_OD_SUPPORT == _ON)
                              CMemorySetODCompress();
                              CMemorySetODFIFO();
                              CMemorySetODOnOff(_ON);
                              #endif
              
                      //080324
                              if((_GET_INPUT_SOURCE() == _SOURCE_VGA))// || (_GET_INPUT_SOURCE() == _SOURCE_YPBPR))
                              {
                                      CAdjustAdcClock(stModeUserData.Clock, 1);
                                      CAdjustAdcClock(stModeUserData.Clock, 2);
                              }       
                              
                      CPowerPanelOn();
              
                              if (GET_LIGHTPOWERSTATUS() == _OFF) 
                              {
                          CPowerLightPowerOn();
                              }
              
                              #if (_YPBPR_NONE_CHECK_APLL)
                              if(_GET_INPUT_SOURCE() == _SOURCE_YPBPR)
                              CAdjustDisableWatchDog(_WD_ALL);                        // Disable watch dog
                              //      CAdjustEnableWatchDog(_WD_DV_TIMEOUT | _WD_FRAMESYNC);  // not to watch APLL mis-Lock,hill 20070417
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 8   

                              else
                              #endif          
              
                      if (bCNoCheckSyncMode())
                              CAdjustDisableWatchDog(_WD_ALL);                        // Disable watch dog
                      else if (_GET_INPUT_SOURCE()==_SOURCE_VGA)
                                  CAdjustEnableWatchDog(_WD_DV_TIMEOUT | _WD_FRAMESYNC);      // not to watch APLL mis-Lock,hill 20070417
                      else
                                      CAdjustEnableWatchDog(_WD_ALL);
              
                      SET_OSD_READYFORDISPLAY(); 
              
                     // if (GET_FIRST_SHOW_NOTE())
                     //    ucOsdEventMsg = _DO_SHOW_NOTE;   
                        
                      }
              
                      if ((stModeUserData.FirstAuto == 0) &&   ///!do auto config when go to vga first time
                              (_GET_INPUT_SOURCE() == _SOURCE_VGA)) 
                      {
                              stModeUserData.FirstAuto = 1;
                      //ucOsdEventMsg = _DO_AUTO_CONFIG;
                      }
              
              #endif
 448   1      }
 449          
 450          //--------------------------------------------------
 451          // Description  : Measure sync type
 452          // Input Value  : None
 453          // Output Value : Return _TRUE if succeed
 454          //--------------------------------------------------
 455          bit CSyncHandler(void)
 456          {
 457   1              if (ucInputSyncType == _NO_SYNC_STATE)
 458   1              {
 459   2                      if (!CSourceHandler())   //input Source not exist
 460   2                      {
 461   3                              ucInputSyncType = _NO_SYNC_STATE;
 462   3                              return _FALSE;
 463   3                      }
 464   2                      
 465   2              if (_SOURCE_DVI == _GET_INPUT_SOURCE() || _SOURCE_HDMI == _GET_INPUT_SOURCE())
 466   2                         CTimerDelayXms(5);
 467   2             // else
 468   2                  CTimerDelayXms(4);
 469   2                      
 470   2                      ucInputSyncType = CSyncMeasureSyncType();
 471   2      
 472   2                      switch (ucInputSyncType)
 473   2                      {
 474   3                      case _NO_SYNC_STATE:
 475   3                              return _FALSE;
 476   3                              
 477   3                      case _SS_STATE:
 478   3                      case _CS_STATE:
 479   3                      case _SOG_STATE:
 480   3                              return _TRUE;
 481   3                              
 482   3                      #if(_YPBPR_SUPPORT == _ON)
                              case _SOY_STATE:
                                      #if(_YPBPR_NEW_SYNC_DETECT == _ON)
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 9   

                                      CScalerSetBit(_SYNC_INVERT_48, ~_BIT2,0x00);
                                      #endif
                                      return _TRUE;
                              #endif
 489   3                              
 490   3                      #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON))
 491   3                      case _DSS_STATE:
 492   3                              #if (_HDMI_SUPPORT == _ON)
 493   3                              if(CHdmiFormatDetect())//Input source is the HDMI format.
 494   3                  {
 495   4                                      if(CHdmiFormatDetect())         //Input source is the HDMI format.
 496   4                      {
 497   5                          if (!GET_HDMIINPUT())//_GET_INPUT_SOURCE() != _SOURCE_HDMI)
 498   5                          {
 499   6                             // _SET_INPUT_SOURCE(_SOURCE_HDMI);
 500   6                              CModeResetMode();
 501   6                          }
 502   5                      }
 503   4                      else
 504   4                          CLR_HDMIINPUT();
 505   4      
 506   4                                      //      _SET_INPUT_SOURCE(_SOURCE_DVI);
 507   4                  }
 508   3                              #endif
 509   3                               return _TRUE;
 510   3                      #endif
 511   3                                      
 512   3                      default:
 513   3                              ucInputSyncType = _NO_SYNC_STATE;
 514   3                              return _FALSE;
 515   3                      }
 516   2              }
 517   1              else
 518   1              {
 519   2                      switch (_GET_INPUT_SOURCE())
 520   2                      {
 521   3      
 522   3                      #if(_YPBPR_SUPPORT == _ON)
                              case _SOURCE_YPBPR:
                              #endif
 525   3      
 526   3                      case _SOURCE_VGA:
 527   3                              CScalerSetBit(_SYNC_CTRL_49, ~(_BIT1 | _BIT0), _BIT1);
 528   3                              break;
 529   3                              
 530   3                      #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON))
 531   3                      case _SOURCE_DVI:
 532   3              case _SOURCE_HDMI:
 533   3                              CScalerSetBit(_SYNC_CTRL_49, ~(_BIT1 | _BIT0), 0x00);
 534   3                              break;
 535   3                      #endif
 536   3      
 537   3                      }
 538   2                      return _TRUE;
 539   2          }
 540   1      }
 541          
 542          /**
 543          * CSyncMeasureSyncType
 544          * Measure sync type
 545          * called only by CSyncHandler
 546          * identify sync type according to the input source
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 10  

 547          * @param <none>
 548          * @return {sync type we measured}
 549          *
 550          */
 551          
 552          BYTE CSyncMeasureSyncType(void)
 553          {
 554   1              BYTE synctypetemp;
 555   1              
 556   1              switch (CGetSourcePortType(_GET_INPUT_SOURCE()))
 557   1              {
 558   2      
 559   2              #if(_YPBPR_SUPPORT == _ON)
                      case _YPBPR_A0_PORT:
                      #endif
 562   2      
 563   2              case _DSUB_A0_PORT:
 564   2              //      if(CGetSourcePortType(_GET_INPUT_SOURCE()) == _DSUB_A0_PORT)
 565   2                              CScalerSetBit(_SYNC_SELECT_47, ~(_BIT3 | _BIT2), 0x00);//SOY0 , 1st HS/VS                                               
 566   2              //      else
 567   2              //              CScalerSetBit(_SYNC_SELECT_47, ~(_BIT3 | _BIT2), (_BIT3 | _BIT2));//SOY1 ,2nd HS/VS     
 568   2                      
 569   2                      //HS_RAW/SOY,source selection
 570   2                      CScalerSetBit(_SYNC_SELECT_47, ~_BIT4, ((BYTE)bHsyncSelection << 4));
 571   2                      synctypetemp    = CSyncSearchSyncTypeVGA();
 572   2                      break;
 573   2                      
 574   2              #if(_YPBPR_SUPPORT == _ON)
                      case _YPBPR_A1_PORT:
                      #endif
 577   2      
 578   2              case _DSUB_A1_PORT:
 579   2              //      if(CGetSourcePortType(_GET_INPUT_SOURCE()) == _DSUB_A0_PORT)
 580   2              //              CScalerSetBit(_SYNC_SELECT_47, ~(_BIT3 | _BIT2), 0x00);//SOY0 , 1st HS/VS                                               
 581   2              //      else
 582   2                              CScalerSetBit(_SYNC_SELECT_47, ~(_BIT3 | _BIT2), (_BIT3 | _BIT2));//SOY1 ,2nd HS/VS     
 583   2                      
 584   2                      //HS_RAW/SOY,source selection
 585   2                      CScalerSetBit(_SYNC_SELECT_47, ~_BIT4, ((BYTE)bHsyncSelection << 4));
 586   2                      synctypetemp    = CSyncSearchSyncTypeVGA();
 587   2                      break;
 588   2                      
 589   2              #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON))
 590   2              case _DVI_PORT:
 591   2              case _HDMI_PORT:
 592   2          case _DVI_D0_PORT:
 593   2          case _DVI_D1_PORT:
 594   2          case _HDMI_D0_PORT:
 595   2          case _HDMI_D1_PORT:
 596   2                      synctypetemp = CSyncSearchSyncTypeDVI();
 597   2                      break;
 598   2                             /*
 599   2              case _DVI_I_A0_PORT:
 600   2                      synctypetemp = CSyncSearchSyncTypeDVI();
 601   2                      if (synctypetemp == _NO_SYNC_STATE)
 602   2                      {
 603   2                              CScalerSetBit(_SYNC_SELECT_47, ~(_BIT3 | _BIT2), 0x00);
 604   2                              CScalerSetBit(_SYNC_SELECT_47, ~_BIT4, ((BYTE)bHsyncSelection << 4));
 605   2                              synctypetemp = CSyncSearchSyncTypeVGA();
 606   2                      }
 607   2                      break;
 608   2                            */
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 11  

 609   2              #endif//(_TMDS_SUPPORT == _ON)
 610   2                      
 611   2              default:
 612   2                      break;
 613   2                      
 614   2              }
 615   1              
 616   1              #if(_HSYNC_TYPE_DETECTION == _AUTO_RUN)
 617   1              if (1)
 618   1              #endif
 619   1                      
 620   1              #if(_HSYNC_TYPE_DETECTION == _NORMAL_RUN)
                  if (synctypetemp != _SS_STATE)
                      #endif
 623   1      
 624   1              {
 625   2                      CAdjustSyncProcessorMeasureStart();
 626   2                      
 627   2                      if (CTimerPollingEventProc(60, CMiscModeMeasurePollingEvent))
 628   2                      {
 629   3                              if (CModeMeasureData())
 630   3                                      CSyncModifyPolarityVGA();
 631   3                              else
 632   3                                      synctypetemp = _NO_SYNC_STATE;
 633   3                      }
 634   2                      else
 635   2                              synctypetemp = _NO_SYNC_STATE;
 636   2              }
 637   1                      
 638   1              return synctypetemp;
 639   1      }
 640          
 641          /**
 642          * CSyncSearchSyncTypeVGA
 643          * Search VGA sync type
 644          * if the same type is searched for 3 times return sync type
 645          * @param <none>
 646          * @return {sync type}
 647          *
 648          */
 649          //--------------------------------------------------
 650          // Description  : Search VGA sync type
 651          // Input Value  : None
 652          // Output Value : Return sync type
 653          //--------------------------------------------------
 654          BYTE CSyncSearchSyncTypeVGA(void)
 655          {
 656   1              #define _SYNCTYPE_CONFIRM_TIMES   3
 657   1              
 658   1              BYTE synctypeprev, synctypecurr, cnt;
 659   1              
 660   1              cnt = _SYNCTYPE_CONFIRM_TIMES;
 661   1              
 662   1              do
 663   1              {
 664   2                      #if(_HSYNC_TYPE_DETECTION == _NORMAL_RUN)
                              synctypecurr = CSyncGetSyncTypeStepVGA();
                              #elif(_HSYNC_TYPE_DETECTION == _AUTO_RUN)
 667   2              synctypecurr = CSyncGetSyncTypeAutoRun();
 668   2                      #endif
 669   2                      
 670   2                      if (cnt == _SYNCTYPE_CONFIRM_TIMES)
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 12  

 671   2                      {
 672   3                              synctypeprev = synctypecurr;
 673   3                              continue;
 674   3                      }
 675   2                      
 676   2                      if (synctypecurr != synctypeprev)
 677   2                      {
 678   3                              return _NO_SYNC_STATE;
 679   3                      }
 680   2                      
 681   2              }
 682   1              while (--cnt);
 683   1              
 684   1              return synctypecurr;
 685   1              
 686   1              #undef _SYNCTYPE_CONFIRM_TIMES
 687   1      }
 688          
 689          #if(_HSYNC_TYPE_DETECTION == _NORMAL_RUN)
              /**
              * CSyncGetSyncTypeStepVGA
              * Get VGA sync type according to sync detection by detecting registers
              * @param <none>
              * @return {sync type}
              *
              */
              BYTE CSyncGetSyncTypeStepVGA(void)
              {
                  BYTE flag, cnt = 0;
                      
                  CScalerPageSelect(_PAGE0);
                  CScalerSetByte(_P0_ADC_POWER_AD, 0x18);//DCR  enable,1M
                      
                  CScalerSetByte(_VGIP_ODD_CTRL_13, 0x00);
                  CScalerSetByte(_YUV2RGB_CTRL_9C, 0x00);//disable YUV->RGB
                  CScalerSetBit(_IPH_ACT_WID_H_16, ~(_BIT7 | _BIT3), 0x00);
                  CScalerSetBit(_SCALE_CTRL_32, ~_BIT7, 0x00); //disable video compensation
                  CScalerSetBit(_SYNC_CTRL_49, ~(_BIT2 | _BIT1 | _BIT0), _BIT2 | _BIT1); // SeHS/DeHS ,ADC_HS/ADC/VS
                  CScalerSetBit(_SYNC_INVERT_48, ~(_BIT4 | _BIT2), (_BIT4 | _BIT2));// HS_OUT ,clamp output enable
                      
                  if((bit)CScalerGetBit(_SYNC_SELECT_47, _BIT4)) //V304 modify
                  {
                      CScalerPageSelect(_PAGE0);
                      CScalerSetByte(_P0_ADC_TEST_CTRL_AF, 0x04);
                  }
                      
                  CScalerSetBit(_SYNC_SELECT_47, ~_BIT5, _BIT5);  //Enable De-composite circuit
                      
                      // Vsync counter level 384 crystal clocks
                  CScalerSetBit(_VSYNC_COUNTER_LEVEL_MSB_4C, ~(_BIT2 | _BIT1 | _BIT0), 0x03);//768Hsync
                  CScalerSetByte(_VSYNC_COUNTER_LEVEL_LSB_4D, 0x00);
                      
                  do
                  {
                      CScalerSetBit(_STABLE_MEASURE_4F, ~_BIT0, 0x00);
                      CScalerSetBit(_STABLE_MEASURE_4F, ~_BIT0, _BIT0);//Measure start
                              
                      if(!CTimerPollingEventProc(20, CMiscStableFlagPollingEvent))
                      {
                                      if((bit)CScalerGetBit(_HSYNC_TYPE_DETECTION_FLAG_4E, _BIT7))//HS_Overflow
                                              return _NO_SYNC_STATE;  //No signal
                                      else
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 13  

                                              return _NO_SYNC_STATE;  //Not support
                      }
                              
                      CScalerSetBit(_STABLE_MEASURE_4F, ~_BIT1, _BIT1);//Pop up stable value
                              
                      if(!(bit)CScalerGetBit(_STABLE_MEASURE_4F, _BIT6))//Stable polarity
                      {
                                      CScalerSetBit(_SYNC_INVERT_48, ~_BIT3, CScalerGetBit(_SYNC_INVERT_48, _BIT3) ^ _BIT3);
                                      cnt++;
                      }
                      else
                                      break;
                              
                              if(cnt >= 2)
                                      return _NO_SYNC_STATE;
                      }
                      while(_TRUE);
                      
                      CScalerSetByte(_HSYNC_TYPE_DETECTION_FLAG_4E, 0xff);
                      CTimerDelayXms(40);
                      flag = CScalerGetBit(_HSYNC_TYPE_DETECTION_FLAG_4E, 0xff);
                      
                      if((bit)(flag & _BIT6) || (bit)(flag & _BIT5) || (bit)(flag & _BIT3))// 1.Stable period chang 2.Stable po
             -larity chang 3.window unlock
                              return _NO_SYNC_STATE;
                      else if((bit)(flag & _BIT1))  // Composite-Sync
                      {
                              CScalerSetBit(_SYNC_CTRL_49, ~(_BIT6 | _BIT5 | _BIT2), (_BIT6 | _BIT5 | _BIT2));// 1.DeHS 2.DeVS3..
                              if((bit)(flag & _BIT0))   // Not SOY signal
                              {
                                      CScalerSetBit(_SYNC_INVERT_48, ~(_BIT6 | _BIT1), (_BIT6 | _BIT1));
              
                                      if((bit)(flag & _BIT2))
                                              return _CS_STATE;  //CS with Equalizer
                                      else
                                              return _CS_STATE;  //OR-Type & XOR-Type CS
                              }
                              else
                              {
                                      CScalerSetBit(_SYNC_INVERT_48, ~(_BIT6 | _BIT1), 0x00);
              
                                      if((bit)(flag & _BIT2))
                                              return _SOY_STATE;  //YPbPr
                                      else
                                      {
                                              #if(_YPBPR_SUPPORT == _ON)
                              if((bit)CScalerGetBit(_SYNC_SELECT_47, _BIT4))
                                  return _SOY_STATE;
                              else
                                                      return _CS_STATE;
                                              #else
                              return _CS_STATE;
                                              #endif
                                      }
                              }
                      }
                      else                    // Check if Hsync only
                      {
                              CScalerSetBit(_SYNC_CTRL_49, ~(_BIT6 | _BIT5 | _BIT2), _BIT2);
                              CScalerSetBit(_SYNC_SELECT_47, ~_BIT5, 0x00);  //Disable De-composite circuit
                              CAdjustSyncProcessorMeasureStart();
              
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 14  

                              if(CTimerPollingEventProc(60, CMiscModeMeasurePollingEvent))
                              {
                                      if(CModeMeasureData())
                                      {
                                              CSyncModifyPolarityVGA();
                                              return _SS_STATE;
                                      }
                                      else
                                              return _NO_SYNC_STATE;
                              }
                              else
                                      return _NO_SYNC_STATE;
                      }
              }
              #endif  // End of #if(_HSYNC_TYPE_DETECTION == _NORMAL_RUN)
 809          
 810          /**
 811          * CSyncModifyPolarityVGA
 812          * Modify VGA sync polarity
 813          * @param <none>
 814          * @return {none}
 815          *
 816          */
 817          //--------------------------------------------------
 818          // Description  : Modify VGA sync polarity
 819          // Input Value  : None
 820          // Output Value : None
 821          //--------------------------------------------------
 822          void CSyncModifyPolarityVGA(void)
 823          {
 824   1              BYTE polarity;
 825   1              
 826   1              polarity = CScalerGetBit(_VGIP_SIGINV_11, 0xff);
 827   1              polarity &= ~(_BIT3 | _BIT2);
 828   1              
 829   1              if(!(bit)(stModeInfo.Polarity & _BIT0))
 830   1                      polarity |= _BIT2;
 831   1              
 832   1              if(!(bit)(stModeInfo.Polarity & _BIT1))
 833   1                      polarity |= _BIT3;
 834   1              
 835   1              CScalerSetByte(_VGIP_SIGINV_11, polarity);
 836   1      }
 837          
 838          /**
 839          * CSyncSearchSyncTypeDVI
 840          * Search DVI sync type
 841          * called only by CSyncMeasureSyncType
 842          * if the same type is searched for 3 times return sync type
 843          * @param <none>
 844          * @return {sync type}
 845          *
 846          */
 847          //--------------------------------------------------
 848          // Description  : Search DVI sync type
 849          // Input Value  : None
 850          // Output Value : Return sync type
 851          //--------------------------------------------------
 852          #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON))
 853          BYTE CSyncSearchSyncTypeDVI(void)
 854          {
 855   1              BYTE synctypetemp = _DSS_STATE;
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 15  

 856   1      
 857   1              //initial DVI register setting add by frank
 858   1              CScalerSetByte(_VGIP_ODD_CTRL_13, 0x00);
 859   1      
 860   1              #if(_HDMI_SUPPORT == _ON)       
 861   1              if(!CHdmiFormatDetect())
 862   1              #endif
 863   1                      CScalerSetByte(_YUV2RGB_CTRL_9C, 0x00);
 864   1              
 865   1              CScalerSetBit(_IPH_ACT_WID_H_16, ~(_BIT7 | _BIT3), 0x00);
 866   1              CScalerSetBit(_SCALE_CTRL_32, ~_BIT7, 0x00);
 867   1              CScalerSetBit(_VSYNC_COUNTER_LEVEL_MSB_4C, ~_BIT3, 0x00);
 868   1              
 869   1              CPowerADCAPLLOff();
 870   1              
 871   1              CScalerPageSelect(_PAGE2);
 872   1              if(!CSourceScanInputPortDVI((bit)CScalerGetBit(_P2_POWER_ON_OFF_CTRL_A7, _BIT7)))
 873   1                      return _NO_SYNC_STATE;
 874   1              
 875   1              #if(((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON)) && (_DVI_LONG_CABLE_SUPPORT == _ON))
                  if(CAdjustTMDSEqualizer() == _FALSE)
                      return _NO_SYNC_STATE;
                      #endif
 879   1              
 880   1              CPowerTMDSOn(); // Measure HS/VS source select as TMDS
 881   1              
 882   1              return synctypetemp;
 883   1      }
 884          #endif  // End of #if(_TMDS_SUPPORT == _ON)
 885          
 886          
 887          
 888          #if(_HSYNC_TYPE_DETECTION == _AUTO_RUN)
 889          /**
 890          * CSyncGetSyncTypeAutoRun
 891          * Get VGA sync type by Hsync Type Detection Auto Run
 892          * @param <none>
 893          * @return {sync type}
 894          *
 895          */
 896          BYTE CSyncGetSyncTypeAutoRun(void)
 897          {
 898   1              BYTE synctemp;
 899   1              
 900   1          CScalerPageSelect(_PAGE0);
 901   1          CScalerSetBit(_P0_ADC_POWER_C6, ~(_BIT5 | _BIT4 | _BIT3), (_BIT5 | _BIT4 | _BIT3));//ADC RGB power
 902   1          CScalerSetBit(_IPH_ACT_WID_H_16, ~_BIT7, 0x00);
 903   1          CScalerSetBit(_SCALE_CTRL_32, ~_BIT7, 0x00); //video mode compensation disable
 904   1          CScalerSetBit(_SYNC_CTRL_49, ~(_BIT2 | _BIT1 | _BIT0), _BIT2 | _BIT1);// ADC_HS/ADC_VS ,SeHS/DeHS
 905   1              CScalerSetByte(_P0_ADC_CLAMP_CTRL1_D5, 0x00);//clamp to black_Low
 906   1      
 907   1          if((bit)CScalerGetBit(_SYNC_SELECT_47, _BIT3)) // SOG1/SOY1
 908   1              CScalerSetBit(_P0_ADC_SOG_CTRL_D6, ~(_BIT1 | _BIT0), _SOY_RESISTER);// R=500K,10n
 909   1          else // SOG0/SOY0
 910   1              CScalerSetBit(_P0_ADC_SOG_CTRL_D6, ~(_BIT3 | _BIT2), (_SOY_RESISTER << 2));// R=500K,10n                
 911   1              
 912   1              CScalerSetBit(_STABLE_MEASURE_4F, ~_BIT0, 0x00);//Measure- Clear
 913   1              CScalerSetBit(_STABLE_MEASURE_4F, ~_BIT0, _BIT0);//Measure- Start
 914   1              
 915   1              CTimerDelayXms(5);
 916   1              
 917   1              if((bit)CScalerGetBit(_HSYNC_TYPE_DETECTION_FLAG_4E, _BIT7))
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 16  

 918   1          {// Hsync overflow
 919   2                      return _NO_SYNC_STATE;
 920   2          }
 921   1      
 922   1              //eric 20070523 VGA long time wake up 
 923   1              CTimerDelayXms(60);
 924   1      
 925   1          if(!((bit)CScalerGetBit(_STABLE_MEASURE_4F, _BIT7)))//both polarity and period are stable
 926   1              return _NO_SYNC_STATE;
 927   1              CScalerSetBit(_STABLE_MEASURE_4F, ~_BIT1, _BIT1);//Pop up result
 928   1              
 929   1          // Get stable period
 930   1              CScalerRead(_STABLE_PERIOD_H_50, 2, pData, _AUTOINC);
 931   1              ((WORD *)pData)[1] = ((pData[0] & 0x07) << 8) | pData[1];
 932   1              
 933   1              if(_GET_INPUT_SOURCE() == _SOURCE_VGA)
 934   1          {
 935   2                      CScalerSetBit(_VSYNC_COUNTER_LEVEL_MSB_4C, ~(_BIT2 | _BIT1 | _BIT0), (BYTE)(((WORD *)pData)[1] >> 10) & 
             -0x07);
 936   2                      CScalerSetByte(_VSYNC_COUNTER_LEVEL_LSB_4D, (BYTE)(((WORD *)pData)[1] >> 2));
 937   2              }
 938   1              else
 939   1          {
 940   2                      if(((WORD *)pData)[1]<=0x500)   
 941   2              {
 942   3                              if((((WORD *)pData)[1]<=0x2D4)&&(((WORD *)pData)[1]>=0x2C9))
 943   3                              {
 944   4                                      //720P50
 945   4                                      CScalerSetBit(_VSYNC_COUNTER_LEVEL_MSB_4C, ~(_BIT2 | _BIT1 | _BIT0), (BYTE)(((WORD *)pData)[1] >> 8) &
             - 0x07);
 946   4                                      CScalerSetByte(_VSYNC_COUNTER_LEVEL_LSB_4D, (BYTE)(((WORD *)pData)[1] ));
 947   4                              }
 948   3                              else
 949   3                              {
 950   4                                      //480p (_STABLE_PERIOD=0x6B3)
 951   4                                      CScalerSetBit(_VSYNC_COUNTER_LEVEL_MSB_4C, ~(_BIT2 | _BIT1 | _BIT0), (BYTE)(((WORD *)pData)[1] >> 10) 
             -& 0x07);
 952   4                                      CScalerSetByte(_VSYNC_COUNTER_LEVEL_LSB_4D, (BYTE)(((WORD *)pData)[1] >> 2));                           
 953   4                              }
 954   3                      }
 955   2                      else
 956   2              {
 957   3                              //480i (_STABLE_PERIOD=0x359)
 958   3                              CScalerSetBit(_VSYNC_COUNTER_LEVEL_MSB_4C, ~(_BIT2 | _BIT1 | _BIT0), (BYTE)(((WORD *)pData)[1] >> 9) & 
             -0x07);
 959   3                              CScalerSetByte(_VSYNC_COUNTER_LEVEL_LSB_4D, (BYTE)(((WORD *)pData)[1] >> 1));
 960   3                      }               
 961   2              }
 962   1              
 963   1              CScalerSetBit(_STABLE_MEASURE_4F, ~_BIT0, 0x00);//stable measure stop
 964   1              
 965   1              CScalerSetBit(_SYNC_SELECT_47, ~_BIT6, 0x00);
 966   1              CScalerSetBit(_SYNC_SELECT_47, ~_BIT6, _BIT6);  //Enable hsync type detection auto run
 967   1              
 968   1              if(CTimerPollingEventProc(90, CMiscHsyncTypeAutoRunFlagPollingEvent)) //auto run ready
 969   1              {
 970   2                      synctemp = (CScalerGetBit(_VSYNC_COUNTER_LEVEL_MSB_4C, 0xff) & 0x70) >> 4;//Measur result
 971   2                      ucStablePol = ~(CScalerGetBit(_STABLE_PERIOD_H_50, _BIT6) >> 6); //Get Hsync Polarity
 972   2      
 973   2                      #if(_YPBPR_AUTO_SOY == _ENABLE)
                              if(_GET_INPUT_SOURCE() == _SOURCE_YPBPR)
                      {
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 17  

                                      if((synctemp == 0)||(synctemp == 1))
                          {   // No-signal or Not-support                     
                                              SyncLevelOffset++;
                                              CYPbPrAutoSOY();                // Adjust SOG sync level
                                      }
                              }
                              #endif
 983   2      
 984   2                      switch(synctemp)
 985   2                      {//eric 20070530
 986   3                      case _NO_SIGNAL:                // No Signal
 987   3                      case _NOT_SUPPORT:              // Not Support
 988   3                      case _HSYNC_WITHOUT_VS: // Hsync only
 989   3                              synctemp =_NO_SYNC_STATE;       
 990   3                              break;                                          
 991   3                              
 992   3                      case _YPBPR_SYNC:               // YPbPr-Type CS
 993   3                              synctemp =_SOY_STATE;
 994   3                              break;  
 995   3                              
 996   3                      case _SERRATION_CS:             // Serration-Type CS
 997   3                              #if(_YPBPR_SUPPORT == _ON)
                                      #if(_HSYNC_TYPE_SELECT == _HSYNC_WITH_SOG_SOY)
                                      if((bit)CScalerGetBit(_SYNC_SELECT_47, _BIT4))
                                      {
                                              if(CModeMeasureReady())
                                              {
                                                      if(CModeMeasureData())
                                                      {
                                                              if((stModeInfo.IHFreq < Panel[ucPanelSelect]->HSyncMinFreq) || (stModeInfo.IHFreq > Panel[ucPanelSel
             -ect]->HSyncMaxFreq) || (stModeInfo.IVFreq < Panel[ucPanelSelect]->VSyncMinFreq) || (stModeInfo.IVFreq > Panel[ucPanelSel
             -ect]->VSyncMaxFreq))
                                                              {
                                                                      synctemp=_NO_SYNC_STATE;
                                                                      break;                                                                  
                                                              }
                                                              else
                                                              {                                               
                                                                      if(CYPbPrSearchMode() != _MODE_NOSUPPORT)
                                                                              synctemp = _SOY_STATE;                                                          
                                                                      else
                                                                              synctemp =_CS_STATE;                                                                                            
                                                                      break;                  
                                                              }
                                                      }
                                              }
                                              else
                                              {
                                                      synctemp = _NO_SYNC_STATE;
                                                      break;                                                  
                                              }
                                      }
                                      else
                                      {
                                              synctemp =_CS_STATE;
                                              break;                                          
                                      }            
                                      #else
                                      if(_GET_INPUT_SOURCE() == _SOURCE_YPBPR)
                                              synctemp =_SOY_STATE;                                                                                   
                                      else
                                              synctemp = _CS_STATE;
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 18  

                                      break;                          
                                      
                                      #endif  //End of #if(_HSYNC_TYPE_SELECT == _HSYNC_WITH_SOG_SOY)
                                      #else
1040   3                              synctemp =_CS_STATE;
1041   3                              break;                  
1042   3                              #endif
1043   3                              
1044   3                      case _XOR_OR_TYPE_CS_WITH_EQR:          // CS with Equalizer
1045   3                      case _XOR_OR_TYPE_CS_WITHOUT_EQR:               // OR-Type & XOR-Type CS
1046   3                              synctemp =_CS_STATE;
1047   3                              break;                          
1048   3                              
1049   3                      case _SEPARATE_HSYNC:           // Separate Sync
1050   3                              synctemp =_SS_STATE;
1051   3                              break;                          
1052   3                              
1053   3                      default:                // Hsync only
1054   3                              synctemp =_NO_SYNC_STATE;                               
1055   3                      }
1056   2                      
1057   2              }
1058   1              else
1059   1                      synctemp =_NO_SYNC_STATE;       
1060   1              
1061   1              #if(_HSYNC_TYPE_SELECT != _HSYNC_ONLY)
1062   1              if((synctemp != _NO_SYNC_STATE) && ((bit)CScalerGetBit(_SYNC_SELECT_47, _BIT4)))
1063   1              {
1064   2                      CScalerRead(_STABLE_HIGH_PERIOD_H_4A, 2, pData, _AUTOINC);
1065   2                      stModeInfo.IHSyncPulseCount = ((pData[0] & 0x07) << 8) | pData[1];
1066   2                      
1067   2                      CScalerRead(_STABLE_PERIOD_H_50, 2, pData, _AUTOINC);
1068   2                      stModeInfo.IHCount = ((pData[0] & 0x07) << 8) | pData[1];
1069   2                      
1070   2                      if(((stModeInfo.IHSyncPulseCount * 7 / stModeInfo.IHCount) != 0) || (stModeInfo.IHSyncPulseCount < 4))
1071   2                              synctemp = _NO_SYNC_STATE;
1072   2          }
1073   1              #endif  // End of #if(_HSYNC_TYPE_SELECT != _HSYNC_ONLY)
1074   1              
1075   1              return synctemp;        
1076   1              
1077   1      }
1078          #endif  // End of #if(_HSYNC_TYPE_DETECTION == _AUTO_RUN)
1079          
1080          
1081          #if(_YPBPR_AUTO_SOY == _ENABLE)
              void CYPbPrAutoSOY(void)
              {
                      if((SOGSyncLevel - SyncLevelOffset) < MinSOGSyncLevel)
                              SyncLevelOffset = 0;
                      CScalerPageSelect(_PAGE0); //_P0_SOG0_CTRL_AB
                      
                      //eric 20070530
                  if(CGetSourcePortType(_GET_INPUT_SOURCE()) == _YPBPR_A0_PORT)       
                      CScalerSetByte(_P0_ADC_SOG0_CTRL_D2,SOGSyncLevel - SyncLevelOffset);
                  else
                  {
                      CScalerPageSelect(_PAGEB);
                      CScalerSetByte(_PB_SOYCH0_CFG3_C3,SOGSyncLevel - SyncLevelOffset);
                  }
              }
              #endif
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 19  

1098          
1099          
1100          #if (_HDMI_HOT_PLUG_OPTION == _ENABLE)
              /*
              //eric 20070326 philips DVD
              void CModeHDMIStableConfirm(void)
              {
                      if((_GET_INPUT_SOURCE() == _SOURCE_HDMI || _GET_INPUT_SOURCE() == _SOURCE_DVI)||(CHdmiFormatDetect()))
                      {
                              if(bHDMIFrameOk==_FALSE)
                                      ucHDMIFrameOkCnt ++;
                              
                              if(ucHDMIFrameOkCnt>=7)//_HDMI_OK_CNT)
                              {
                                      bHDMIFrameOk=_TRUE;
                                      ucHDMIChangeCnt=0;
                                      ucHDMIFrameOkCnt=0;
                              }       
                      }       
              
              }*/
                  
              void CModeHDMIChageDelay(void)
              {
                      if((_GET_INPUT_SOURCE() == _SOURCE_HDMI || _GET_INPUT_SOURCE() == _SOURCE_DVI)||(CHdmiFormatDetect()))
                      {
                              //eric 20070326 philips DVD                                             
                              ucHDMIChangeCnt++;
                              bHDMIFrameOk=_FALSE;
                      
                              if(ucHDMIChangeCnt>=10)//_HDMI_CHANGE_CNT)
                              {
                                      ucHDMIChangeCnt=0;                                                      
                                      CModeHdmiHP();
                              }       
                      }               
              }       
              #endif
1136          
1137          //--------------------------------------------------
1138          bit bCNoCheckSyncMode(void)
1139          {
1140   1      
1141   1          if ((_GET_INPUT_SOURCE()==_SOURCE_VGA) && 
1142   1                                                  (stModeInfo.ModeCurr == (_MODE_1440x900_60HZ_RB) ||
1143   1                                                   stModeInfo.ModeCurr == (_MODE_1440x900_60HZ)    ||
1144   1                                                   stModeInfo.ModeCurr == (_MODE_1440x900_75HZ)    ||
1145   1                                                   stModeInfo.ModeCurr == (_MODE_1024x768_72HZ)    ||
1146   1                                                   stModeInfo.ModeCurr == (_MODE_1024x768_70HZ)))
1147   1              return _TRUE;
1148   1      
1149   1          if ((_GET_INPUT_SOURCE()==_SOURCE_DVI) && 
1150   1                                                  (stModeInfo.ModeCurr == (_MODE_1440x900_60HZ_RB) ||
1151   1                                                   stModeInfo.ModeCurr == (_MODE_1440x900_60HZ)))//    ||
1152   1                                                 //  stModeInfo.ModeCurr == (_MODE_1024x768_72HZ)    ||
1153   1                                                   //stModeInfo.ModeCurr == (_MODE_1024x768_70HZ)))
1154   1              return _TRUE;
1155   1      
1156   1      
1157   1      
1158   1          return _FALSE;
1159   1      }
C51 COMPILER V7.20   SYNC                                                                  10/05/2015 09:30:04 PAGE 20  

1160          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1811    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =      3    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
