C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 1   


C51 COMPILER V7.20, COMPILATION OF MODULE ADJUST
OBJECT MODULE PLACED IN .\Output\Adjust.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Core\code\Adjust.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(
                    -.\Output\Adjust.lst) OBJECT(.\Output\Adjust.obj)

line level    source

   1          /*===========================================================
   2           * Copyright (c)      Realtek Semiconductor Corporation, 2005
   3           * All rights reserved.
   4           * ========================================================== */
   5          
   6          /*==================== File Description ===================== */
   7          /**
   8           * @file
   9           *      This file is osd control declaration related functions.
  10           *
  11           * @author      $Author: Dgoetz $
  12           * @date        $Date: 2/12/15 11:01a $
  13           * @version     $Revision: 2 $
  14           * @ingroup Auto
  15           */
  16          
  17          /**
  18           * @addtogroup Auto
  19           * @{
  20           */
  21          
  22          #define _ADJUST_C
  23          /*===================== Module dependency  ================== */
  24          #include "Core\Header\Include.h"
  25          
  26          /*======================= Private Types ===================== */
  27          
  28          /*======================== Definitions ====================== */
  29          
  30          /*========================== Variables ====================== */
  31          //BYTE idata ucAdjustCtrl = 0;
  32          
  33          /*=================== Local Functions Phototype ==============*/
  34          static void CAdjustSetSharpnessTable(bit scaling,BYTE code *pArray0, BYTE code *pArray1);
  35          void CAdjustPeakingCoring(void);
  36          void CAdjustPeakingFilter(SBYTE ucPeaking);
  37          
  38          /*=========================== Functions ===================== */
  39          //--------------------------------------------------
  40          // Description  : Adjust IHS delay
  41          // Input Value  : IHS delay
  42          // Output Value : None
  43          //--------------------------------------------------
  44          void CAdjustIHSDelay(WORD usIHSDelay)
  45          {
  46   1          CScalerSetBit(_VGIP_HV_DELAY_1E, ~_BIT0, HIBYTE(usIHSDelay) & _BIT0);
  47   1          CScalerSetByte(_IHS_DELAY_1D, LOBYTE(usIHSDelay));
  48   1      }
  49          
  50          //--------------------------------------------------
  51          // Description  : Adjust IVS delay
  52          // Input Value  : IVS delay
  53          // Output Value : None
  54          //--------------------------------------------------
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 2   

  55          void CAdjustIVSDelay(WORD usIVSDelay)
  56          {
  57   1          CScalerSetBit(_VGIP_HV_DELAY_1E, ~_BIT1, (usIVSDelay >> 7) & _BIT1);
  58   1          CScalerSetByte(_IVS_DELAY_1C, LOBYTE(usIVSDelay));
  59   1      }
  60          
  61          //--------------------------------------------------
  62          // Description  : Adjust Dclk offset
  63          // Input Value  : Dclk offset
  64          // Output Value : None
  65          //--------------------------------------------------
  66          void CAdjustDclkOffset(WORD usDclkOffset)
  67          {
  68   1              CScalerPageSelect(_PAGE1);
  69   1          CScalerSetBit(_P1_DCLK_FINE_TUNE_OFFSET_MSB_C4, 0xf0, HIBYTE(usDclkOffset) & 0x0f);
  70   1          CScalerSetByte(_P1_DCLK_FINE_TUNE_OFFSET_LSB_C5, LOBYTE(usDclkOffset));
  71   1          CScalerSetBit(_P1_DCLK_SPREAD_SPECTRUM_C6, ~_BIT2, _BIT2);
  72   1      }
  73          
  74          //--------------------------------------------------
  75          // Description  : Adjust spread spectrum range
  76          // Input Value  : Spread spectrum range
  77          // Output Value : None
  78          //--------------------------------------------------
  79          void CAdjustSpreadSpectrumRange(BYTE ucSpreadRange)
  80          {
  81   1          CScalerPageSelect(_PAGE1);
  82   1          CScalerSetBit(_P1_DCLK_SPREAD_SPECTRUM_C6, 0x0f, (ucSpreadRange << 4) & 0xf0);
  83   1          CScalerSetBit(_P1_DCLK_SPREAD_SPECTRUM_C6, ~_BIT2, _BIT2);
  84   1      }
  85          
  86          //--------------------------------------------------
  87          // Description  : Sync processor measure start
  88          // Input Value  : None
  89          // Output Value : None
  90          //--------------------------------------------------
  91          void CAdjustSyncProcessorMeasureStart(void)
  92          {
  93   1          CScalerSetBit(_MEAS_HS_PERIOD_H_52, ~_BIT5, _BIT5);
  94   1      }
  95          
  96          //--------------------------------------------------
  97          // Description  : Turn on the error correction function
  98          // Input Value  : None
  99          // Output Value : None
 100          //--------------------------------------------------
 101          void CAdjustTMDSErrorCorrectionOn(void)
 102          {
 103   1          CScalerPageSelect(_PAGE2);
 104   1          CScalerSetBit(_P2_UP_DOWN_CTRL2_B7, ~(_BIT7 | _BIT6 | _BIT5), _BIT7);
 105   1      }
 106          
 107          #if(((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON)) && (_DVI_LONG_CABLE_SUPPORT == _ON))
              //--------------------------------------------------
              // Description  : Measure TMDS transition result
              // Input Value  : ucType    --> _TMDS_MEASURE_AVE, _TMDS_MEASURE_MAX, _TMDS_MEASURE_MIN
              //                ucSelect  --> _TMDS_MEASURE_HSYNC_BE, _TMDS_MEASURE_HSYNC_AF, _TMDS_MEASURE_DE_BE, _TMDS
             -_MEASURE_DE_AF
              // Output Value : Transition result
              //--------------------------------------------------
              BYTE CAdjustTMDSMeasure(BYTE ucType, BYTE ucSelect)
              {
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 3   

                      BYTE result;
              
                  CScalerPageSelect(_PAGE2);
                  CScalerSetBit(_P2_TMDS_MEAS_RESULT0_A2, ~(_BIT6 | _BIT5), (ucType << 5));
                  CScalerSetBit(_P2_TMDS_MEAS_RESULT0_A2, ~(_BIT7 | _BIT4 | _BIT3), (_BIT7 | (ucSelect << 3)));
              
                  if(CTimerPollingEventProc(60, CMiscTMDSMeasureEvent) == _FALSE)
                  {
                      CScalerSetBit(_P2_TMDS_MEAS_RESULT0_A2, ~_BIT7, 0x00);
                      return 0xff;
                  }
              
                  CScalerRead(_P2_TMDS_MEAS_RESULT1_A3, 1, &result, _NON_AUTOINC);
              
                  return (result & 0x7f);
              }
              
              //--------------------------------------------------
              // Description  : TMDS CRC check process before displaying
              // Input Value  : None
              // Output Value : None
              //--------------------------------------------------
              void CAdjustTMDSCRCCheck(void)
              {
                  BYTE temp0, temp1;
                  DWORD dsod0, dsod1;
              
                  if(GET_FRAMESYNCSTATUS())
                  {
                      CTimerDelayXms(20);
              
                      temp0 = 0;
                      temp0 += CAdjustTMDSCRC(&pData[8]);
                      temp0 += CAdjustTMDSCRC(&pData[12]);
                      dsod0 = abs(((DWORD *)pData)[2] - ((DWORD *)pData)[3]);
              
                      if(temp0 < 2)
                      {
                              CScalerPageSelect(_PAGE2);
                              CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT5 | _BIT6), CScalerGetBit(_P2_ANALOG_COMMON_CTRL2
             -_AB, (_BIT6 | _BIT5)) ^ (_BIT5 | _BIT6));
              
                              temp1 = 0;
                                      temp1 += CAdjustTMDSCRC(&pData[8]);
                                      temp1 += CAdjustTMDSCRC(&pData[12]);
                                      dsod1 = abs(((DWORD *)pData)[2] - ((DWORD *)pData)[3]);
              
                                      if(temp1 < 2)
                                      {
                                              if(GET_USE_TRANSITION_RESULT())
                                              {
                                                      CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT5 | _BIT6), CScalerGetBit(_P2_ANALOG_COMMON_CTRL2_AB,
             - (_BIT6 | _BIT5)) ^ (_BIT5 | _BIT6));
                                              }
                                      else
                                              {
                                                      if(dsod0 <= dsod1)
                                                              CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT5 | _BIT6), CScalerGetBit(_P2_ANALOG_COMMON_CTRL2_AB
             -, (_BIT6 | _BIT5)) ^ (_BIT5 | _BIT6));
                                              }
                                      }
                                      else
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 4   

                                      {
                                              //CModeSetDigitalCapture();
                                      }
                              }
                              else
                              {
                                      //CModeSetDigitalCapture();
                              }
                      }
              }
              
              //--------------------------------------------------
              // Description  : Get TMDS transition difference
              // Input Value  : ucPar     --> _MEASURE_HSYNC or _MEASURE_DE
              // Output Value : Transition difference result
              //--------------------------------------------------
              BYTE CAdjustTMDSEqualizerCheck(BYTE ucPar)
              {
                  BYTE result0, result1;
              
                  if(ucPar == _MEASURE_HSYNC)
                  {
                      result0 = CAdjustTMDSMeasure(_TMDS_MEASURE_MAX, _TMDS_MEASURE_HSYNC_BE);
                      if(result0 == 0xff)     return 0xff;
                      else if(result0 < 6)    return 0xfe;
              
                      result1 = CAdjustTMDSMeasure(_TMDS_MEASURE_MIN, _TMDS_MEASURE_HSYNC_AF);
                      if(result1 == 0xff)     return 0xff;
                      else if(result1 < 6)    return 0xfe;
                  }
                  else if(ucPar == _MEASURE_DE)
                  {
                      result0 = CAdjustTMDSMeasure(_TMDS_MEASURE_MAX, _TMDS_MEASURE_DE_BE);
                      if(result0 == 0xff)     return 0xff;
                      else if(result0 < 6)    return 0xfe;
              
                      result1 = CAdjustTMDSMeasure(_TMDS_MEASURE_MAX, _TMDS_MEASURE_DE_AF);
                      if(result1 == 0xff)     return 0xff;
                      else if(result1 < 6)    return 0xfe;
                  }
              
                  result0 = abs(result0 - result1);
              
                  if(result0 <= 2)
                      result0 = 0;
              
                  return result0;
              }
              
              //--------------------------------------------------
              // Description  : Adjust TMDS equalizer setting
              // Input Value  : None
              // Output Value : return _TRUE if success
              //--------------------------------------------------
              bit CAdjustTMDSEqualizer(void)
              {
                  BYTE cnt, result0, result1;
              
                  CLR_USE_TRANSITION_RESULT();
                  CScalerPageSelect(_PAGE2);
                  CScalerSetByte(_P2_TMDS_MEAS_SELECT_A1, 0x21);
                  CScalerSetBit(_P2_TMDS_MEAS_RESULT0_A2, ~(_BIT6 | _BIT5), _BIT5);
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 5   

              
                  cnt = 1;
                  do
                  {
                      CScalerSetBit(_P2_TMDS_MEAS_SELECT_A1, 0xf0, (cnt%16));
              
                      result0 = CAdjustTMDSMeasure(_TMDS_MEASURE_MAX, _TMDS_MEASURE_DE_BE);
                      if(result0 == 0xff)
                          return _FALSE;
              
                      if(result0 > 80)
                          break;
              
                      cnt++;
                  }
                  while(cnt <= 16);
              
                  cnt = 0;
              
                  CScalerPageSelect(_PAGE2);
                  CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT6 | _BIT5 | _BIT4), 0x00);
                  result0 = CAdjustTMDSEqualizerCheck(_MEASURE_HSYNC);
                  if(result0 == 0xff)     return _FALSE;
                  if(result0 == 0xfe)     cnt += 1;
              
                  CScalerPageSelect(_PAGE2);
                  CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT6 | _BIT5 | _BIT4), _BIT4);
                  result1 = CAdjustTMDSEqualizerCheck(_MEASURE_HSYNC);
                  if(result1 == 0xff)     return _FALSE;
                  if(result1 == 0xfe)     cnt += 2;
              
                  if((abs(result0 - result1) <= 2) || (cnt != 0))
                  {
                      cnt = 0;
              
                      CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT6 | _BIT5 | _BIT4), 0x00);
                      result0 = CAdjustTMDSEqualizerCheck(_MEASURE_DE);
                      if(result0 == 0xff)     return _FALSE;
                      if(result0 == 0xfe)     cnt += 1;
              
                      CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT6 | _BIT5 | _BIT4), _BIT4);
                      result1 = CAdjustTMDSEqualizerCheck(_MEASURE_DE);
                      if(result1 == 0xff)     return _FALSE;
                      if(result1 == 0xfe)     cnt += 2;
                  }
              
                  if((result0 <= result1) || (cnt >= 2))
                      CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT6 | _BIT5 | _BIT4), (_BIT6 | _BIT5 | _BIT4));
              
                  if(abs(result0 - result1) > 2)
                      SET_USE_TRANSITION_RESULT();
              
                  return _TRUE;
              }
              #endif  // End of #if(((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON)) && (_DVI_LONG_CABLE_SUPPORT == _O
             -N))
 292          
 293          #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON))
 294          //--------------------------------------------------
 295          // Description  : Set digital mode capture
 296          // Input Value  : None
 297          // Output Value : None
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 6   

 298          //--------------------------------------------------
 299          void CAdjustSetDigitalCapture(void)
 300          {
 301   1              CScalerSetBit(_VGIP_CTRL_10, ~(_BIT1), _BIT1);
 302   1          CScalerSetBit(_IPH_ACT_STA_H_14, 0xf8, 0x00);
 303   1          CScalerSetByte(_IPH_ACT_STA_L_15, 0x00);
 304   1          CScalerSetBit(_IPV_ACT_STA_H_18, ~(_BIT2 | _BIT1 | _BIT0), _BIT2 | _BIT1 | _BIT0);
 305   1          CScalerSetByte(_IPV_ACT_STA_L_19, 0x00);
 306   1      }
 307          
 308          //--------------------------------------------------
 309          // Description  : Measure TMDS CRC value
 310          // Input Value  : None
 311          // Output Value : CRC value, DWORD data type
 312          //--------------------------------------------------
 313          
 314          //--------------------------------------------------
 315          // Description  : TMDS digital/analog capture check process before displaying
 316          // Input Value  : None
 317          // Output Value : None
 318          //--------------------------------------------------
 319          void CAdjustTMDSCaptureCheck(void)
 320          {
 321   1          BYTE flag = 0;
 322   1      
 323   1          if(flag)
 324   1          {
 325   2              CAdjustSetDigitalCapture();
 326   2              CTimerDelayXms(20);
 327   2          }
 328   1      
 329   1      }
 330          #endif  // End of #if(_TMDS_SUPPORT == _ON)
 331          
 332          #if(_HDCP_SUPPORT == _ON)
 333          //--------------------------------------------------
 334          // Description  : Adjust HDCP key
 335          // Input Value  : None
 336          // Output Value : None
 337          //--------------------------------------------------
 338          void CAdjustHDCP(void)
 339          {
 340   1          CScalerPageSelect(_PAGE2);
 341   1          CScalerSetByte(_P2_HDCP_CTRL_C0, 0x06);
 342   1          CScalerWrite(_P2_DEVICE_KEY_ACCESS_PORT_C1, 320, tHDCP_KEY_TABLE_0, _NON_AUTOINC);
 343   1          CScalerCodeW(tHDCP_CTRL);
 344   1          CScalerSetByte(_P2_HDCP_CTRL_C0, 0x01);
 345   1      }
 346          #endif
 347          
 348          //--------------------------------------------------
 349          // Description  : Enable watch dog
 350          // Input Value  : ucPar --> Parameter for watch dog
 351          // Output Value : None
 352          //--------------------------------------------------
 353          void CAdjustEnableWatchDog(BYTE ucPar)
 354          {
 355   1              // add this line by Moya, we don't enable watch-dog at all.
 356   1              //return;
 357   1          if (bCNoCheckSyncMode())
 358   1              return;
 359   1      
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 7   

 360   1          if(GET_FRAMESYNCSTATUS())
 361   1          {
 362   2              CScalerSetByte(_WATCH_DOG_CTRL0_0C, 0x00);
 363   2              CMiscClearStatusRegister();
 364   2              CScalerSetBit(_WATCH_DOG_CTRL0_0C, ~ucPar, 0x06 | ucPar);  //Ming-Yen
 365   2                      ucPar = ucPar + 0; //Ming-Yen
 366   2          }
 367   1      }
 368          
 369          //--------------------------------------------------
 370          // Description  : Disable watch dog
 371          // Input Value  : ucPar --> Parameter for watch dog
 372          // Output Value : None
 373          //--------------------------------------------------
 374          void CAdjustDisableWatchDog(BYTE ucPar)
 375          {
 376   1          BYTE temp;
 377   1      
 378   1          CScalerSetBit(_WATCH_DOG_CTRL0_0C, ~ucPar, 0x00);
 379   1              temp = CScalerGetBit(_WATCH_DOG_CTRL0_0C, (_BIT7 | _BIT6 | _BIT5 | _BIT4 | _BIT3));
 380   1          if(temp == 0x00)
 381   1              CScalerSetByte(_WATCH_DOG_CTRL0_0C, 0x00);
 382   1      }
 383          
 384          //--------------------------------------------------
 385          // Description  : Adjust gamma
 386          // Input Value  : Gamma table type and gamma tables
 387          // Output Value : None
 388          //--------------------------------------------------
 389          void CAdjustGamma(BYTE ucGammaTableType, BYTE *pGammaTableArrayR, BYTE *pGammaTableArrayG, BYTE *pGammaTab
             -leArrayB)
 390          {
 391   1          WORD cnt;
 392   1          BYTE i, temp;
 393   1      
 394   1          if((ucGammaTableType == _COMPACT_GAMMA_NORMAL_TABLE) || (ucGammaTableType == _FULL_GAMMA_NORMAL_TABLE)
             -)
 395   1          {
 396   2              CScalerSetByte(_GAMMA_CTRL_67, 0x80 | ucGammaTableType);
 397   2              CScalerWrite(_GAMMA_PORT_66, ((ucGammaTableType == _COMPACT_GAMMA_NORMAL_TABLE) ? 256 : 384), pGam
             -maTableArrayR, _NON_AUTOINC);
 398   2              CScalerSetByte(_GAMMA_CTRL_67, 0x90 | ucGammaTableType);
 399   2              CScalerWrite(_GAMMA_PORT_66, ((ucGammaTableType == _COMPACT_GAMMA_NORMAL_TABLE) ? 256 : 384), pGam
             -maTableArrayG, _NON_AUTOINC);
 400   2              CScalerSetByte(_GAMMA_CTRL_67, 0xa0 | ucGammaTableType);
 401   2              CScalerWrite(_GAMMA_PORT_66, ((ucGammaTableType == _COMPACT_GAMMA_NORMAL_TABLE) ? 256 : 384), pGam
             -maTableArrayB, _NON_AUTOINC);
 402   2              CScalerSetByte(_GAMMA_CTRL_67, 0x40);
 403   2          }
 404   1      #if(_GAMMA_TYPE == _FULL_GAMMA_COMPRESS_TABLE2)
                  else if(ucGammaTableType == _FULL_GAMMA_COMPRESS_TABLE2)
                  {
                       CScalerSetByte(_GAMMA_CTRL_67, 0x81);
                      CRtdWriteGamma(pGammaTableArrayR);
                      CScalerSetByte(_GAMMA_CTRL_67, 0x91);
                      CRtdWriteGamma(pGammaTableArrayG);
                      CScalerSetByte(_GAMMA_CTRL_67, 0xa1);
                      CRtdWriteGamma(pGammaTableArrayB);
                      CScalerSetByte(_GAMMA_CTRL_67, 0x40);   
                  }
              #endif  
 416   1          else if((ucGammaTableType == _COMPACT_GAMMA_COMPRESS_TABLE) || (ucGammaTableType == _FULL_GAMMA_COMPRE
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 8   

             -SS_TABLE))
 417   1          {
 418   2              for(i=0;i<3;i++)
 419   2              {
 420   3                  ucVLDCnt    = 0;
 421   3                  ucVLDTemp   = 0;
 422   3      
 423   3                  if(i == 0)
 424   3                  {
 425   4                      CScalerSetByte(_GAMMA_CTRL_67, 0x80 | (ucGammaTableType % 2));
 426   4                      pvldarray   = (pGammaTableArrayR + 16);
 427   4                  }
 428   3                  else if(i == 1)
 429   3                  {
 430   4                      CScalerSetByte(_GAMMA_CTRL_67, 0x90 | (ucGammaTableType % 2));
 431   4                      pvldarray   = (pGammaTableArrayG + 16);
 432   4                  }
 433   3                  else
 434   3                  {
 435   4                      CScalerSetByte(_GAMMA_CTRL_67, 0xa0 | (ucGammaTableType % 2));
 436   4                      pvldarray   = (pGammaTableArrayB + 16);
 437   4                  }
 438   3      
 439   3                  for(temp=0;temp<16;temp++)
 440   3                      pData[temp] = *(pvldarray + temp - 16);
 441   3      
 442   3                  for(cnt=0;cnt<((ucGammaTableType == _COMPACT_GAMMA_COMPRESS_TABLE) ? 256 : 384);cnt++)
 443   3                  {
 444   4                      temp    = CScalerGetVLD() << 4;
 445   4                      temp    |= CScalerGetVLD();
 446   4                      CScalerSetByte(_GAMMA_PORT_66, temp);
 447   4                  }
 448   3              }
 449   2                      CScalerSetByte(_GAMMA_CTRL_67, 0x40);
 450   2              }
 451   1      }
 452          
 453          #if(_GAMMA_TYPE == _FULL_GAMMA_COMPRESS_TABLE2)
              void CRtdWriteGamma(UINT8  *array)
              {
                      int i,k=0,m=0;
                      int tmp;
                      int diff0;
                      int d2;
                      int k0;
               
                      int outA;
              
                      k0=outA=*array++; // //2x+0
                      diff0=*(array++);
              
                      for (i=0;i<256;i+=2)
                      {
                      tmp=*(array++);
                              //---even----------------------
                              d2=(tmp>>4)-8;
                              if (d2==-8)
                              d2=(char)*(array++);
               // dump k0
                              CScalerSetByte(_GAMMA_PORT_66,(k0>>2));
                              outA=outA+diff0; // 2x+1
               // dump d0,
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 9   

                              CScalerSetByte(_GAMMA_PORT_66,(((k0&3)<<6)|diff0));
                              diff0=diff0+d2; // d[2x+1]
              // dump d1
                              if (i==254) 
                                      diff0=0; // Last item :: without d2;
                              CScalerSetByte(_GAMMA_PORT_66,(diff0));
                              m++; 
                              k++;
                              //---odd-----------------------
                              d2=(tmp&0xf)-8;
                              if(d2 == -8)
                                      d2 = (char)*array++;
                              k0 = outA = outA + diff0;
                              diff0 = diff0 + d2; // d[2x+1];
                              m++; 
                              k++;
                      }
              }
              #endif
 497          
 498          //--------------------------------------------------
 499          // Description  : Set dithering
 500          // Input Value  : Dithering tables
 501          // Output Value : None
 502          //--------------------------------------------------
 503          void CAdjustDither(BYTE *pDitherSeqTable, BYTE * pDitherTable)
 504          {
 505   1          CScalerSetBit(_DITHERING_CTRL_6A, ~(_BIT7 | _BIT6), _BIT6);
 506   1          CScalerWrite(_DITHERING_DATA_ACCESS_69, 24, pDitherSeqTable, _NON_AUTOINC);
 507   1          CScalerSetBit(_DITHERING_CTRL_6A, ~(_BIT7 | _BIT6), _BIT7);
 508   1          CScalerWrite(_DITHERING_DATA_ACCESS_69, 24, pDitherTable, _NON_AUTOINC);
 509   1          CScalerSetByte(_DITHERING_CTRL_6A, 0x38);
 510   1      }
 511          
 512          //--------------------------------------------------
 513          // Description  : Adjust sharpness for scale up
 514          // Input Value  : None
 515          // Output Value : None
 516          //--------------------------------------------------
 517          void CAdjustSharpnessForScaleUp(void)
 518          {
 519   1              CAdjustSetSharpnessTable(_SCALE_UP,tSU_COEF_TABLE[GET_SHARPNESS()], tSU_COEF_TABLE[GET_SHARPNESS()]);
 520   1      }
 521          
 522          //--------------------------------------------------
 523          // Description  : Adjust sharpness for scale down
 524          // Input Value  : None
 525          // Output Value : None
 526          //--------------------------------------------------
 527          void CAdjustSharpnessForScaleDown(void)
 528          {
 529   1          CAdjustSetSharpnessTable(_SCALE_DOWN, tSCALE_DOWN_COEF_TABLE[GET_SHARPNESS()], tSCALE_DOWN_COEF_TABLE[
             -GET_SHARPNESS()]);
 530   1      }
 531          
 532          //--------------------------------------------------
 533          // Description  : Set Sharpness Table
 534          // Input Value  : 1: Scale-Up
 535          //                0: Scale-Down  
 536          // Output Value : None
 537          //--------------------------------------------------
 538          void CAdjustSetSharpnessTable(bit scaling, BYTE code *pArray0, BYTE  code *pArray1)
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 10  

 539          {
 540   1          if(scaling)
 541   1          {
 542   2              CScalerSetByte(_FILTER_CTRL_35, 0xb0);
 543   2              CScalerWrite(_FILTER_ACCESS_PORT_36, 128, pArray0, _NON_AUTOINC);
 544   2              CScalerSetByte(_FILTER_CTRL_35, 0xc0);
 545   2              CScalerWrite(_FILTER_ACCESS_PORT_36, 128, pArray1, _NON_AUTOINC);
 546   2              CScalerSetByte(_FILTER_CTRL_35, 0x00);
 547   2      
 548   2              CScalerSetByte(_FILTER_CTRL_35, 0x0b);
 549   2              CScalerWrite(_FILTER_ACCESS_PORT_36, 128, pArray0, _NON_AUTOINC);
 550   2              CScalerSetByte(_FILTER_CTRL_35, 0x0c);
 551   2              CScalerWrite(_FILTER_ACCESS_PORT_36, 128, pArray1, _NON_AUTOINC);
 552   2              CScalerSetByte(_FILTER_CTRL_35, 0x00);
 553   2          }
 554   1          else
 555   1          {
 556   2              CScalerPageSelect(_PAGE6);
 557   2              CScalerSetByte(_P6_UZD_FIR_COEF_INDEX_F3, 0x00);
 558   2              CScalerWrite(_P6_UZD_FIR_COEF_PORT_F4, 64, pArray0, _NON_AUTOINC);
 559   2              CScalerSetByte(_P6_UZD_FIR_COEF_INDEX_F3, 0x80);
 560   2              CScalerWrite(_P6_UZD_FIR_COEF_PORT_F4, 64, pArray1, _NON_AUTOINC);
 561   2              CScalerSetByte(_P6_UZD_FIR_COEF_INDEX_F3, 0x00);
 562   2          }
 563   1      }
 564          
 565          //--------------------------------------------------
 566          // Description  : Adjust color precessing brightness
 567          // Input Value  : None
 568          // Output Value : None
 569          //--------------------------------------------------
 570          void CAdjustSetBrightness(void)
 571          {
 572   1          CScalerSetByte(_CB_ACCESS_PORT_64, 0x80);
 573   1          CScalerWrite(_CB_DATA_PORT_65, 3, pData, _NON_AUTOINC);
 574   1          CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
 575   1      }
 576          
 577          //--------------------------------------------------
 578          // Description  : Adjust color processing contrast
 579          // Input Value  : None
 580          // Output Value : None
 581          //--------------------------------------------------
 582          void CAdjustSetContrast(void)
 583          {
 584   1          CScalerSetByte(_CB_ACCESS_PORT_64, 0x83);
 585   1          CScalerWrite(_CB_DATA_PORT_65, 3, pData, _NON_AUTOINC);
 586   1          CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
 587   1      }
 588          
 589          //--------------------------------------------------
 590          // Description  : Adjust ADC gain
 591          // Input Value  : None
 592          // Output Value : None
 593          //--------------------------------------------------
 594          void CAdjustAdcGain(void)
 595          {
 596   1              if(_GET_INPUT_SOURCE() == _SOURCE_VGA)
 597   1              {
 598   2                      #if(_ADC0_INPUT_SWAP_RG == _ON)
                      pData[1] = stAdcData.AdcGain[_RED];
                      pData[0] = stAdcData.AdcGain[_GREEN];
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 11  

                      pData[2] = stAdcData.AdcGain[_BLUE];
                              #elif(_ADC0_INPUT_SWAP_RB == _ON)
                      pData[2] = stAdcData.AdcGain[_RED];
                              pData[1] = stAdcData.AdcGain[_GREEN];
                              pData[0] = stAdcData.AdcGain[_BLUE];
                              #elif(_ADC0_INPUT_SWAP_GB == _ON)
                      pData[0] = stAdcData.AdcGain[_RED];
                      pData[2] = stAdcData.AdcGain[_GREEN];
                      pData[1] = stAdcData.AdcGain[_BLUE];
                              #else
 611   2              pData[0] = stAdcData.AdcGain[_RED];
 612   2              pData[1] = stAdcData.AdcGain[_GREEN];
 613   2              pData[2] = stAdcData.AdcGain[_BLUE];
 614   2                      #endif//(_ADC_INPUT_SWAP_RG == _ON)
 615   2              }
 616   1              else// if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
 617   1              {
 618   2                      #if(_ADC1_INPUT_SWAP_RG == _ON)
                      pData[1] = stYPbPrData.YPbPrGain[_RED];
                      pData[0] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[2] = stYPbPrData.YPbPrGain[_BLUE];
                              #elif(_ADC1_INPUT_SWAP_RB == _ON)
                      pData[2] = stYPbPrData.YPbPrGain[_RED];
                      pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[0] = stYPbPrData.YPbPrGain[_BLUE];
                              #elif(_ADC1_INPUT_SWAP_GB == _ON)
 627   2              pData[0] = stYPbPrData.YPbPrGain[_RED];
 628   2              pData[2] = stYPbPrData.YPbPrGain[_GREEN];
 629   2              pData[1] = stYPbPrData.YPbPrGain[_BLUE];
 630   2                      #else
                      pData[0] = stYPbPrData.YPbPrGain[_RED];
                      pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[2] = stYPbPrData.YPbPrGain[_BLUE];
                              #endif
 635   2              }
 636   1      
 637   1              {
 638   2                      CScalerPageSelect(_PAGE0);              
 639   2              CScalerWrite(_P0_RED_GAIN_C0, 3, pData, _AUTOINC);
 640   2              }
 641   1      }
 642          
 643          //--------------------------------------------------
 644          // Description  : Adjust ADC offset
 645          // Input Value  : None
 646          // Output Value : None
 647          //--------------------------------------------------
 648          void CAdjustAdcOffset(void)
 649          {
 650   1              if(_GET_INPUT_SOURCE() == _SOURCE_VGA)
 651   1              {
 652   2      #if(_ADC0_INPUT_SWAP_RG == _ON)
                      pData[4] = stAdcData.AdcOffset[_RED];
                      pData[3] = stAdcData.AdcOffset[_GREEN];
                      pData[5] = stAdcData.AdcOffset[_BLUE];
              #elif(_ADC0_INPUT_SWAP_RB == _ON)
                      pData[5] = stAdcData.AdcOffset[_RED];
                      pData[4] = stAdcData.AdcOffset[_GREEN];
                      pData[3] = stAdcData.AdcOffset[_BLUE];
              #elif(_ADC0_INPUT_SWAP_GB == _ON)
                      pData[3] = stAdcData.AdcOffset[_RED];
                      pData[5] = stAdcData.AdcOffset[_GREEN];
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 12  

                      pData[4] = stAdcData.AdcOffset[_BLUE];
              #else
 665   2              pData[3] = stAdcData.AdcOffset[_RED];
 666   2              pData[4] = stAdcData.AdcOffset[_GREEN];
 667   2              pData[5] = stAdcData.AdcOffset[_BLUE];
 668   2      #endif
 669   2              }
 670   1              else 
 671   1          {
 672   2      #if(_ADC1_INPUT_SWAP_RG == _ON)
                      pData[4] = stYPbPrData.YPbPrOffset[_RED];
                      pData[3] = stYPbPrData.YPbPrOffset[_GREEN];
                      pData[5] = stYPbPrData.YPbPrOffset[_BLUE];
              #elif(_ADC1_INPUT_SWAP_RB == _ON)
                      pData[5] = stYPbPrData.YPbPrOffset[_RED];
                      pData[4] = stYPbPrData.YPbPrOffset[_GREEN];
                      pData[3] = stYPbPrData.YPbPrOffset[_BLUE];
              #elif(_ADC1_INPUT_SWAP_GB == _ON)
 681   2              pData[3] = stYPbPrData.YPbPrOffset[_RED];
 682   2                      pData[5] = stYPbPrData.YPbPrOffset[_GREEN];
 683   2              pData[4] = stYPbPrData.YPbPrOffset[_BLUE];
 684   2      #else
                      pData[3] = stYPbPrData.YPbPrOffset[_RED];
                      pData[4] = stYPbPrData.YPbPrOffset[_GREEN];
                      pData[5] = stYPbPrData.YPbPrOffset[_BLUE];
              #endif
 689   2              }
 690   1              {
 691   2              CScalerPageSelect(_PAGE0);
 692   2                      //pData[3] = pData[4] = pData[5] = 0x80;        //provisional ¼È©w
 693   2                      CScalerWrite(_P0_RED_OFFSET_C3, 3, &pData[3], _AUTOINC);
 694   2              }
 695   1      }
 696          
 697          //--------------------------------------------------
 698          // Description  : Adjust ADC gain and offset
 699          // Input Value  : None
 700          // Output Value : None
 701          //--------------------------------------------------
 702          void CAdjustAdcGainOffset(void)
 703          {
 704   1          CAdjustAdcGain();
 705   1          CAdjustAdcOffset();
 706   1      }
 707          
 708          //--------------------------------------------------
 709          // Description  : Adjust background color
 710          // Input Value  : Red, green and blue color settings
 711          // Output Value : None
 712          //--------------------------------------------------
 713          void CAdjustBackgroundColor(BYTE ucRed, BYTE ucGreen, BYTE ucBlue)
 714          {
 715   1          CScalerSetBit(_OVERLAY_CTRL_6C, ~(_BIT5), 0x00);
 716   1          CScalerSetBit(_OVERLAY_CTRL_6C, ~(_BIT5), _BIT5);
 717   1      
 718   1          CScalerSetByte(_BGND_COLOR_CTRL_6D, ucRed);
 719   1          CScalerSetByte(_BGND_COLOR_CTRL_6D, ucGreen);
 720   1          CScalerSetByte(_BGND_COLOR_CTRL_6D, ucBlue);
 721   1      
 722   1          CScalerSetBit(_OVERLAY_CTRL_6C, ~(_BIT5), 0x00);
 723   1      }
 724          
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 13  

 725          //--------------------------------------------------
 726          bit CheckInterLace(void)
 727          {
 728   1              CTimerDelayXms(200);
 729   1              CScalerRead(_IPV_ACT_LEN_H_1A, 1, pData, _NON_AUTOINC);
 730   1              
 731   1              if(pData[0] & 0x20)
 732   1                      return 1;
 733   1                      
 734   1              return 0;
 735   1      }
 736          
 737          //--------------------------------------------------
 738          void CAdjustInterlaceIVS2DVSDelay(void)
 739          {
 740   1          UINT16 usTemp;
 741   1              
 742   1      //    CScalerRead(_IPV_ACT_LEN_H_1A, 1, pData, _NON_AUTOINC);
 743   1      
 744   1              if(CTimerPollingEventProc(5, CheckInterLace))
 745   1          //if(pData[0] & 0x20)
 746   1          {
 747   2              CScalerSetBit(_SCALE_CTRL_32, ~(_BIT7 | _BIT6), _BIT7); 
 748   2              CScalerRead(_IPV_ACT_LEN_H_1A, 2, pData, _AUTOINC);
 749   2              usTemp = (((WORD) pData[0] & 0x07) << 8) | (WORD) pData[1];
 750   2              if(usTemp <= 288)       //480i 576i     
 751   2                      CScalerSetBit(_VGIP_SIGINV_11, ~_BIT4, 0);
 752   2              else
 753   2                      CScalerSetBit(_VGIP_SIGINV_11, ~_BIT4, _BIT4);          
 754   2      
 755   2      
 756   2              CScalerRead(_IV_DV_DELAY_CLK_ODD_41, LENGTH(1), pData, _NON_AUTOINC);
 757   2              usTemp = (WORD)pData[0] * 16 + 16;
 758   2              usTemp += stModeInfo.IHTotal/2;
 759   2      
 760   2              CScalerSetByte(_IV_DV_DELAY_CLK_ODD_41, ((usTemp - 16) / 16));
 761   2                      usTemp -= stModeInfo.IHTotal / 2;
 762   2                      //usTemp += stModeInfo.IHTotal / 2;
 763   2      
 764   2                      CScalerSetByte(_IV_DV_DELAY_CLK_EVEN_42, ((usTemp - 16) / 16));
 765   2      
 766   2                      CScalerSetBit(_FS_DELAY_FINE_TUNING_43, ~_BIT1, _BIT1);
 767   2                      CScalerSetBit(_IPV_ACT_LEN_H_1A, 0xff, 0x20); //forster modified 061123 to fix the frame sync problem
 768   2      
 769   2          }
 770   1      }
 771          
 772          //--------------------------------------------------
 773          // Description  : Calculate the suitable IVS to DVS delay
 774          //                CR[38] : IVS to DVS delay in IHS lines
 775          //                CR[1E] : IVS to DVS delay in ICLK * 16
 776          // Input Value  : Scaling setting
 777          // Output Value : IV to DV delay lines
 778          //--------------------------------------------------
 779          BYTE CAdjustIVS2DVSDelay(BYTE ucOption)
 780          {
 781   1          ((DWORD *)pData)[0] = ((DWORD)stDisplayInfo.DHTotal * stDisplayInfo.DVStartPos) + Panel[ucPanelSelect]
             -->DHStartPos;
 782   1      //    ((DWORD *)pData)[0] = ((DWORD)stDisplayInfo.DHTotal * Panel[ucPanelSelect]->DVStartPos) + Panel[ucPa
             -nelSelect]->DHStartPos;
 783   1          ((DWORD *)pData)[0] = ((DWORD *)pData)[0] * stModeInfo.IVHeight / stDisplayInfo.DVHeight * stModeInfo.
             -IHTotal / stDisplayInfo.DHTotal;
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 14  

 784   1          ((DWORD *)pData)[1] = ((DWORD)stModeInfo.IHTotal * (stModeInfo.IVStartPos - (ucVStartBias + _PROGRAM_V
             -DELAY))) + stModeInfo.IHStartPos - (ucHStartBias + _PROGRAM_HDELAY);
 785   1      
 786   1          if ( (_GET_INPUT_SOURCE() !=_SOURCE_DVI) && (_GET_INPUT_SOURCE() !=_SOURCE_HDMI) )
 787   1          {
 788   2              ((DWORD *)pData)[0] = ((DWORD)stDisplayInfo.DHTotal * Panel[ucPanelSelect]->DVStartPos) + Panel[uc
             -PanelSelect]->DHStartPos;
 789   2              ((DWORD *)pData)[0] = ((DWORD *)pData)[0] * stModeInfo.IVHeight / stDisplayInfo.DVHeight * stModeI
             -nfo.IHTotal / stDisplayInfo.DHTotal;
 790   2              ((DWORD *)pData)[1] = ((DWORD)stModeInfo.IHTotal * (stModeInfo.IVStartPos - (ucVStartBias + _PROGR
             -AM_VDELAY))) + stModeInfo.IHStartPos - (ucHStartBias + _PROGRAM_HDELAY);
 791   2          }
 792   1      
 793   1          if(ucOption & _BIT0)
 794   1          {
 795   2              // V scale-up. Target 2.50 IHS delay
 796   2              // Reg[40] = 0 ==> Delay 1 line
 797   2              //((DWORD *)pData)[1] += (stModeInfo.IHTotal * 1) + 640;
 798   2              //eric 20070620
 799   2              CScalerPageSelect(_PAGE6);
 800   2              //if((CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT1 | _BIT0)) && (~(bit)(CScalerGetBit(_P6_UZD_CTRL0_E3, _
             -BIT4))))
 801   2                      #if(_DE_INTERLACE_SUPPORT == _ON)        
                      if (bSourceVideo())
                      {
                          if (stDisplayInfo.DHWidth < 700)
                                      ((DWORD *)pData)[1] += (stModeInfo.IHTotal * 2) + 640;
                          else
                          {
                              if((~(bit)(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT4))) &&(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT1)
             -)&&(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT0)))
                                      ((DWORD *)pData)[1] += (stModeInfo.IHTotal * 2) + 640;
                              else
                                      ((DWORD *)pData)[1] += (stModeInfo.IHTotal *1) + 640;
                          }
                      }
                      else
                      {
                              if(stModeInfo.IVHeight <= 288)
                              { 
                                      if((~(bit)(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT4))) &&(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT1))&&
                                 (CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT0)) && (Panel[ucPanelSelect]->DHWidth > 700)) // E
             -ricLee 0402 add for YPbPr
                                              ((DWORD *)pData)[1] += (stModeInfo.IHTotal * 3) + 640;
                                      else
                                              ((DWORD *)pData)[1] += (stModeInfo.IHTotal *2) + 640;
                              }
                              else
                              { 
                                      if((~(bit)(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT4))) &&(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT1))&&
                                 (CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT0)) && (Panel[ucPanelSelect]->DHWidth > 700)) // E
             -ricLee 0402 add for YPbPr
                                              ((DWORD *)pData)[1] += (stModeInfo.IHTotal * 2) + 640;
                                      else
                                              ((DWORD *)pData)[1] += (stModeInfo.IHTotal *1) + 640;
                              }
                              }
                              #else
 834   2              if (bSourceVideo() && stDisplayInfo.DHWidth < 700)
 835   2                              ((DWORD *)pData)[1] += (stModeInfo.IHTotal * 2) + 640;
 836   2              else
 837   2              {
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 15  

 838   3                      if((~(bit)(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT4))) &&(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT1))&&(
             -CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT0)))
 839   3                              ((DWORD *)pData)[1] += (stModeInfo.IHTotal * 2) + 640;
 840   3                      else
 841   3                              ((DWORD *)pData)[1] += (stModeInfo.IHTotal *1) + 640;
 842   3              }
 843   2                      #endif
 844   2          }
 845   1          else
 846   1          {
 847   2              if (ucOption & _BIT1)
 848   2              {
 849   3                              // V scale-down. Target 1.75 IHS delay
 850   3                  ((DWORD *)pData)[1]  += stModeInfo.IHTotal + ((DWORD)640 * stModeInfo.IVHeight / stDisplayInfo
             -.DVHeight);
 851   3              }
 852   2              else
 853   2              {
 854   3                  // V no scaling. Target 1.50 IHS delay
 855   3                  ((DWORD *)pData)[1]  += stModeInfo.IHTotal + 640;
 856   3              }
 857   2      
 858   2              // Turn on full-line buffer
 859   2              ((DWORD *)pData)[1]  += stModeInfo.IHTotal;
 860   2              CScalerSetBit(_SCALE_CTRL_32, ~_BIT4, _BIT4);
 861   2          }
 862   1      
 863   1          if (((DWORD *)pData)[0] > ((DWORD *)pData)[1])
 864   1          {
 865   2              // You should never get into this code ....
 866   2          }
 867   1      
 868   1          ((DWORD *)pData)[0]  = ((DWORD *)pData)[1] - ((DWORD *)pData)[0];
 869   1      
 870   1          pData[14] = ((DWORD *)pData)[0] / stModeInfo.IHTotal;
 871   1          pData[15] = (((DWORD *)pData)[0] - ((DWORD)stModeInfo.IHTotal * pData[14])) / 16;
 872   1      
 873   1          CScalerSetBit(_FS_DELAY_FINE_TUNING_43, ~(_BIT1), 0x00);
 874   1          CScalerSetByte(_IVS2DVS_DELAY_LINES_40, pData[14]);
 875   1          CScalerSetByte(_IV_DV_DELAY_CLK_ODD_41, pData[15]);
 876   1      
 877   1          return pData[14];
 878   1      }
 879          
 880          
 881          //--------------------------------------------------
 882          // Description  : Set display clock (Dclk) frequency in kHz
 883          // Input Value  : ulFreq    --> Target Dclk frequency
 884          // Output Value : None
 885          //--------------------------------------------------
 886          void CAdjustDPLL(DWORD ulFreq)
 887          {
 888   1      /*
 889   1          WORD mcode;
 890   1          BYTE div;
 891   1      
 892   1          // We want to set DPLL offset to middle(2048), so the target DPLL M/N setting should be 16/15 of targe
             -t frequency.
 893   1          mcode   = ulFreq * 8 * _DPLL_N_CODE * 16 / ((DWORD)_RTD_XTAL * 15);
 894   1      
 895   1          div     = 1;                                                // Output DPLL for DCLK
 896   1          mcode   = (mcode + 2) >> 2;                 // Round to integer
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 16  

 897   1      
 898   1      
 899   1          // Original Formula : M_Code/Ich = 36.67 must be constant
 900   1          // Ich   = M_Code * 100 / 3667
 901   1          // Ich   = 1u + D0[0]*1u + D0[1]*2u + D0[2]*4u + D0[3]*8u (A)
 902   1      
 903   1          // Calculate the Ich,
 904   1          pData[5]    = ((WORD)mcode * 100 / 3667) - 1;
 905   1          pData[6]    = 0x00;
 906   1      
 907   1          if(pData[5] >= 8)
 908   1          {
 909   1              pData[5]    -= 8;
 910   1              pData[6]    |= 0x08;
 911   1          }
 912   1      
 913   1          if(pData[5] >= 4)
 914   1          {
 915   1              pData[5]    -= 4;
 916   1              pData[6]    |= 0x04;
 917   1          }
 918   1      
 919   1          if(pData[5] >= 2)
 920   1          {
 921   1              pData[5]    -= 2;
 922   1              pData[6]    |= 0x02;
 923   1          }
 924   1      
 925   1          if(pData[5] >= 1)
 926   1          {
 927   1              pData[5]    -= 1;
 928   1              pData[6]    |= 0x01;
 929   1          }
 930   1      
 931   1          pData[0]    = mcode - 2;
 932   1      #if(_M2PLL_USE == _ON)
 933   1          pData[1]    = ((1 == div) ? 0x00 : 0x10) | ((_DPLL_N_CODE / _RTD_M2PLL_RATIO) - 2);
 934   1      #else
 935   1          pData[1]    = ((1 == div) ? 0x00 : 0x10) | (_DPLL_N_CODE - 2);
 936   1      #endif
 937   1          pData[2]    = 0x80 | pData[6];
 938   1          pData[3]    = 0x17;
 939   1      
 940   1          CScalerPageSelect(_PAGE1);
 941   1          CScalerWrite(_P1_DPLL_M_BF, 4, pData, _AUTOINC);
 942   1          CScalerSetBit(_P1_DPLL_OTHER_C3, ~_BIT1, _BIT1);
 943   1          if((bit)CScalerGetBit(_P1_DPLL_N_C0, _BIT7))
 944   1          {
 945   1              CScalerSetBit(_P1_DPLL_N_C0, ~_BIT6, _BIT6);
 946   1              CTimerDelayXms(2);
 947   1              CScalerSetBit(_P1_DPLL_N_C0, ~_BIT6, 0x00);
 948   1          }
 949   1      
 950   1      
 951   1          // Dclk frequency in Hz
 952   1          ((DWORD *)pData)[0] = (DWORD)_RTD_XTAL * 1000 / (div * 2) * mcode / _DPLL_N_CODE;
 953   1      
 954   1          // Offset resolution (Dclk / 2^15) in Hz
 955   1          ((DWORD *)pData)[1] = ((DWORD *)pData)[0] >> 15;
 956   1      
 957   1          // Target frequency of Dclk in Hz
 958   1          mcode       = (((DWORD *)pData)[0] - (ulFreq * 1000)) / ((DWORD *)pData)[1];
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 17  

 959   1          mcode       = mcode & 0x0fff;
 960   1      
 961   1              //Enable DDS spread spectrum output function
 962   1              CScalerSetBit(_P1_EVEN_FIXED_LAST_LINE_CTRL_CA, ~_BIT0, _BIT0);
 963   1      
 964   1          CAdjustDclkOffset(mcode); */
 965   1          WORD mcode;
 966   1          BYTE div;
 967   1      
 968   1          // We want to set DPLL offset to middle(2048), so the target DPLL M/N setting should be 16/15 of targe
             -t frequency.
 969   1      #if(_TEST_DPLL)
              
                  mcode   = ulFreq * 8 * _DPLL_N_CODE * 16 / ((DWORD)_RTD_XTAL * 15);
              
                  if(mcode > 255)
                  {
                      div     = 1;                            // Output DPLL for DCLK
                      mcode   = (mcode + 2) >> 2;             // Round to integer
                  }
                  else
                  {
                      div     = 2;                            // Output DPLL/2 for DCLK
                      mcode   = (mcode + 1) >> 1;             // Round to integer
                  }
              
                  // Original Formula : M_Code/Ich = 17.6 must be constant
                  // Ich   = M_Code * 10 / 176
                  // 2*Ich = M_Code * 20 / 176 , set D0[5] to 0, then I = 2 * Ich
                  // I     = 2 * Ich = 2.5u + D0[0]*2.5u + D0[1]*5u + D0[2]*10u + D0[3]*20u + D0[4]*30u (A)
                  // 2*I   = 4 * Ich = 5u + D0[0]*5u + D0[1]*10u + D0[2]*20u + D0[3]*40u + D0[4]*60u (A)
              
                  // Calculate the 4 * Ich,
                  pData[5]    = ((WORD)mcode * 4 * 10 / 176) - 5;
                  pData[6]    = 0x00;
                  
                  if(pData[5] >= 60)
                  {
                      pData[5]    -= 60;
                      pData[6]    |= 0x10;
                  }
              
                  if(pData[5] >= 40)
                  {
                      pData[5]    -= 40;
                      pData[6]    |= 0x08;
                  }
              
                  if(pData[5] >= 20)
                  {
                      pData[5]    -= 20;
                      pData[6]    |= 0x04;
                  }
              
                  if(pData[5] >= 10)
                  {
                      pData[5]    -= 10;
                      pData[6]    |= 0x02;
                  }
              
                  if(pData[5] >= 5)
                  {
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 18  

                      pData[5]    -= 5;
                      pData[6]    |= 0x01;
                  }
              
                  pData[0]    = mcode - 2;
              #if(_M2PLL_USE == _ON)
                  pData[1]    = ((1 == div) ? 0x00 : 0x10) | ((_DPLL_N_CODE / _RTD_M2PLL_RATIO) - 2);
              #else
                  pData[1]    = ((1 == div) ? 0x00 : 0x10) | (_DPLL_N_CODE - 2);
              #endif
                  pData[2]    = 0x40 | pData[6]; 
                  pData[3]    = 0x0f;
              
              #else  //#if(_TEST_DPLL) 
1034   1       
1035   1          mcode   = ulFreq * 8 * _DPLL_N_CODE * 16 / ((DWORD)_RTD_XTAL * 15);
1036   1      
1037   1              //DebugPrintf("\n CAdjustDPLL =%x, ",(UINT8)(mcode>>8));
1038   1              //DebugPrintf("%x ",(UINT8)(mcode));
1039   1              if((GET_PNL_OUTPUT_BUS() == _PANEL_TTL) || (Panel[ucPanelSelect]->DHWidth < 1100))
1040   1          {    /*
1041   2                      if(mcode<38)
1042   2              {
1043   2                              div     = 8;                                                            // Output DPLL/2 for DCLK
1044   2                              mcode   = (mcode + 0) <<1;                      // Round to integer
1045   2                      }               
1046   2                      if(mcode<120)*/
1047   2                      if(mcode<38)
1048   2              {
1049   3      //            div     = 4;                            // Output DPLL/2 for DCLK
1050   3        //          mcode   = (mcode + 1) >> 1;             // Round to integer
1051   3                  div     = 2;                            // Output DPLL/2 for DCLK
1052   3                  mcode   = (mcode + 1) >> 1;             // Round to integer
1053   3                      }               
1054   2                      else if(mcode<120)
1055   2              {
1056   3                              div     = 4;                                                            // Output DPLL/2 for DCLK
1057   3                              mcode   = (mcode + 0) >> 0;                     // Round to integer
1058   3                              //div     = 2;                                          // Output DPLL/2 for DCLK
1059   3                              //mcode   = (mcode + 1) >> 1;           // Round to integer
1060   3                      }
1061   2                      else
1062   2              {
1063   3                          div     = 1;                                        // Output DPLL for DCLK
1064   3                          mcode   = (mcode + 2) >> 2;         // Round to integer
1065   3                      }
1066   2              }
1067   1              else
1068   1          {
1069   2                      div     = 1;                                                    // Output DPLL for DCLK
1070   2                      mcode   = (mcode + 2) >> 2;             // Round to integer
1071   2              }               
1072   1                 
1073   1          // Original Formula : M_Code/Ich = 36.67 must be constant
1074   1          // Ich   = M_Code * 100 / 3667
1075   1          // Ich   = 1u + D0[0]*1u + D0[1]*2u + D0[2]*4u + D0[3]*8u (A)
1076   1      
1077   1          // Calculate the Ich,
1078   1          pData[5]    = ((WORD)mcode * 100 / 3667) - 1;
1079   1          pData[6]    = 0x00;
1080   1      
1081   1          if(pData[5] >= 8)
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 19  

1082   1          {
1083   2              pData[5]    -= 8;
1084   2              pData[6]    |= 0x08;
1085   2          }
1086   1      
1087   1          if(pData[5] >= 4)
1088   1          {
1089   2              pData[5]    -= 4;
1090   2              pData[6]    |= 0x04;
1091   2          }
1092   1      
1093   1          if(pData[5] >= 2)
1094   1          {
1095   2              pData[5]    -= 2;
1096   2              pData[6]    |= 0x02;
1097   2          }
1098   1      
1099   1          if(pData[5] >= 1)
1100   1          {
1101   2              pData[5]    -= 1;
1102   2              pData[6]    |= 0x01;
1103   2          }
1104   1      
1105   1          pData[0]    = mcode - 2;
1106   1      #if(_M2PLL_USE == _ON)
                  pData[1]    = ((1 == div) ? 0x00 : 0x10) | ((_DPLL_N_CODE / _RTD_M2PLL_RATIO) - 2);
              #else
1109   1              if((GET_PNL_OUTPUT_BUS() == _PANEL_TTL) || (Panel[ucPanelSelect]->DHWidth < 1100))
1110   1          {
1111   2                      if(div==2)
1112   2                              pData[1]    = 0x10 | (_DPLL_N_CODE - 2);
1113   2                      else if(div==4)
1114   2                              pData[1]    = 0x20 | (_DPLL_N_CODE - 2);        
1115   2                      else//div==1
1116   2                              pData[1]    = 0x00 | (_DPLL_N_CODE - 2);
1117   2              }
1118   1              else    
1119   1                      pData[1]    = ((1 == div) ? 0x00 : 0x10) | (_DPLL_N_CODE - 2);
1120   1      #endif
1121   1          pData[2]    = 0x80 | pData[6];
1122   1          pData[3]    = 0x17;
1123   1      
1124   1      #endif
1125   1      
1126   1          CScalerPageSelect(_PAGE1);
1127   1          CScalerWrite(_P1_DPLL_M_BF, 4, pData, _AUTOINC);
1128   1          CScalerSetBit(_P1_DPLL_OTHER_C3, ~_BIT1, _BIT1);
1129   1          if((bit)CScalerGetBit(_P1_DPLL_N_C0, _BIT7))
1130   1          {
1131   2              CScalerSetBit(_P1_DPLL_N_C0, ~_BIT6, _BIT6);
1132   2              CTimerDelayXms(2);
1133   2              CScalerSetBit(_P1_DPLL_N_C0, ~_BIT6, 0x00);
1134   2          }
1135   1      
1136   1          // Dclk frequency in Hz
1137   1          ((DWORD *)pData)[0] = (DWORD)_RTD_XTAL * 1000 / (div * 2) * mcode / _DPLL_N_CODE;
1138   1      
1139   1          // Offset resolution (Dclk / 2^15) in Hz
1140   1          ((DWORD *)pData)[1] = ((DWORD *)pData)[0] >> 15;
1141   1      
1142   1          // Target frequency of Dclk in Hz
1143   1          mcode       = (((DWORD *)pData)[0] - (ulFreq * 1000)) / ((DWORD *)pData)[1];
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 20  

1144   1          mcode       = mcode & 0x0fff;
1145   1      
1146   1              //Enable DDS spread spectrum output function
1147   1              CScalerSetBit(_P1_EVEN_FIXED_LAST_LINE_CTRL_CA, ~_BIT0, _BIT0);
1148   1      
1149   1          CAdjustDclkOffset(mcode);
1150   1      }
1151          
1152          //--------------------------------------------------
1153          // Description  :
1154          // Input Value  :
1155          // Output Value :
1156          //--------------------------------------------------
1157          void CAdjustUpdateCenterData(void)
1158          {
1159   1          WORD delta;
1160   1      
1161   1          stModeUserCenterData.CenterHPos     = stModeUserData.HPosition;
1162   1          stModeUserCenterData.CenterVPos     = stModeUserData.VPosition;
1163   1      
1164   1          CAdjustCheckAdcClockRange(stModeUserData.Clock, &delta);
1165   1      
1166   1          if(delta < _CLOCK_BIAS)
1167   1          {
1168   2              stModeUserCenterData.CenterClock = stModeInfo.IHTotal;
1169   2          }
1170   1          else
1171   1          {
1172   2              if(stModeUserData.Clock < stModeInfo.IHTotal)
1173   2              {
1174   3                  if((stModeUserData.Clock - stModeInfo.IHTotal + delta) < _CLOCK_BIAS)
1175   3                  {
1176   4                      stModeUserCenterData.CenterClock = stModeInfo.IHTotal - delta + _CLOCK_BIAS;
1177   4                  }
1178   3                  else
1179   3                  {
1180   4                      stModeUserCenterData.CenterClock = stModeUserData.Clock;
1181   4                  }
1182   3              }
1183   2              else
1184   2              {
1185   3                  if((stModeInfo.IHTotal + delta - stModeUserData.Clock) < _CLOCK_BIAS)
1186   3                  {
1187   4                      stModeUserCenterData.CenterClock = stModeInfo.IHTotal + delta - _CLOCK_BIAS;
1188   4                  }
1189   3                  else
1190   3                  {
1191   4                      stModeUserCenterData.CenterClock = stModeUserData.Clock;
1192   4                  }
1193   3              }
1194   2          }
1195   1      }
1196          
1197          //--------------------------------------------------
1198          // Description  : Check if the ADC clock (IHTotal) is out of range. Range = (BackPorch + FrontPorch) * 2 /
             - 5 .
1199          // Input Value  : usClock   --> ADC Clock (IHTotal)
1200          // Output Value : Return _TRUE if not out of range
1201          //--------------------------------------------------
1202          bit CAdjustCheckAdcClockRange(WORD usClock, WORD *delta)
1203          {
1204   1          *delta   = (stModeInfo.IHTotal - stModeInfo.IHWidth * 8 / 10) / 2;
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 21  

1205   1      
1206   1          if((usClock > stModeInfo.IHTotal) && ((usClock - stModeInfo.IHTotal) > *delta))
1207   1              return _FALSE;
1208   1      
1209   1          if((usClock <= stModeInfo.IHTotal) && ((stModeInfo.IHTotal - usClock) > *delta))
1210   1              return _FALSE;
1211   1      
1212   1          // yc 060222 for usClock error no display
1213   1          if(usClock < (stModeInfo.IHStartPos + _CAPTURE_HDELAY - (ucHStartBias + _PROGRAM_HDELAY) + stModeInfo.
             -IHWidth))
1214   1              return _FALSE;
1215   1      
1216   1          return _TRUE;
1217   1      }
1218          
1219          //080324
1220          #if(1)
1221          //--------------------------------------------------
1222          // Description  : Set ADC clock (IHTotal)
1223          // Input Value  : usClock   --> Target ADC clock
1224          // Output Value : None
1225          //--------------------------------------------------
1226          #define _G_VALUE_DIVIDER_0  4
1227          #define _G_VALUE_DIVIDER_1  16
1228          #define _G_VALUE_DIVIDER_2  64
1229          #define _G_VALUE_DIVIDER_3  128
1230          #define _G_VALUE_DIVIDER_4  256
1231          #define _G_VALUE_DIVIDER_5  512
1232          
1233          //cyyeh 20080222 start
1234          void CAdjustAdcClock(WORD usClock , BYTE ucControl)
1235          {
1236   1              DWORD pllclock, icode;
1237   1              BYTE mcode;
1238   1              SBYTE STemp;
1239   1              WORD pcode;
1240   1              BYTE vco_divider = 2;
1241   1      
1242   1          if(ucControl == 1)
1243   1              CAdjustAPLLFastLock(usClock);
1244   1          else if(ucControl == 2)
1245   1              CAdjustAdcClock_OSD(usClock);
1246   1          else
1247   1          {
1248   2              CAdjustEnableWatchDog(_WD_DV_TIMEOUT);
1249   2              CScalerPageSelect(_PAGE1);
1250   2      /********************************************************
1251   2      Fvco : Frequency of APLL
1252   2      Fxtal : Frequency of Crystal
1253   2      IHF : Input Horizontal Frequency
1254   2      usClock : Divider number of input clock
1255   2      stModeInfo.IHFreq = 10 * IHF(in KHz)
1256   2      _RTD_XTAl : Defined crystal clock unit in KHz
1257   2       
1258   2      Fvco = Fxtal*(M + K/16)/N1 = IHF * usClock * vco_divider
1259   2      Assum N1 = 2
1260   2      (M + K/16) = IHF * usClock * N1 * vco_divider / Fxtal
1261   2      stModeInfo.IHFreq UINT in 100Hz
1262   2      *********************************************************/
1263   2              //ADC sampling clock, UNIT in KHz
1264   2              pllclock = (DWORD)stModeInfo.IHFreq * usClock / 10;  
1265   2              vco_divider = pllclock < 100000 ? 4 : 2;   
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 22  

1266   2              //Get (M + K/16) * 1024
1267   2              pllclock  = ((pllclock * _APLL_N_CODE * vco_divider) << 10 ) / _RTD_XTAL;
1268   2              CScalerPageSelect(_PAGE1);
1269   2              CScalerSetByte(_P1_PLL_DIV_CTRL_A0, 0x08);
1270   2              CScalerSetByte(_P1_DDS_MIX_2_B9, 0xff);
1271   2              CScalerSetByte(_P1_PLL_CRNT_AE, 0x65);
1272   2              CScalerSetBit(_P1_PLLDIV_H_B1, ~(_BIT6 | _BIT5 | _BIT4), (vco_divider == 2) ? (_BIT6 | _BIT5) : (_BI
             -T6 | _BIT5 | _BIT4));
1273   2              //Set the divide number
1274   2              CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
1275   2              CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
1276   2              CAdjustGetAPLLSetting(usClock);
1277   2              //Set N code
1278   2              CScalerSetBit(_P1_PLL_N_AD, 0xf8, ((_APLL_N_CODE - 2) & 0x07));
1279   2              //Get M, K code, M + K/16 = pllclock / 1024
1280   2              mcode = pllclock >> 10; //M is the integer part
1281   2              //CScalerSetByte(0x04,mcode );
1282   2              //K is the fraction part quantized by 16
1283   2              STemp = ((DWORD)pllclock - ((DWORD)mcode << 10)) >> 6;
1284   2              //K is range from -8 ~ 7
1285   2              if(STemp>7)
1286   2              {
1287   3                      mcode +=1;
1288   3                      STemp -= 16;
1289   3              }
1290   2              else if(STemp<(-8))
1291   2              {
1292   3                      mcode -=1;
1293   3                      STemp += 16;
1294   3              }
1295   2              //set M, N, K code
1296   2              CScalerSetByte(_P1_PLL_M_AC, (mcode - 3)); 
1297   2              CScalerSetBit(_P1_PLL_N_AD, 0x0f, (((STemp & 0x0f) << 4) | (_APLL_N_CODE - 2)));
1298   2              CScalerSetByte(0xA4, 0x80);
1299   2              CTimerDelayXms(1);
1300   2              CScalerRead(0xA4, 2, pData, _AUTOINC);
1301   2              usPEValue =  ( ((pData[0]&0x0F)<<8) | pData[1] );
1302   2              usPEValue = 1000000/(usPEValue*(_RTD_XTAL/1000));   // unit : ps
1303   2      /****************************************************************************
1304   2              Formula :
1305   2      
1306   2                I_gain       Ths                    PE(UNIT)                   1
1307   2              --------- x  ------- = ------------------------------------ x  -----
1308   2                 2^22        Tbck        Txclk x 16N/(16M +- K) x 1/16         8
1309   2      
1310   2                I_gain         Ths                      PE(UNIT)                   1
1311   2              --------- x  ----------- = ------------------------------------ x  -----
1312   2                 2^22       Tclk x N         Txclk x 16N/(16M +- K) x 1/16         8
1313   2      
1314   2                         2^22 x PE_U x (16M +- K)        1
1315   2              I_gain = ----------------------------- x -----
1316   2                                   Ths                   8
1317   2      
1318   2                  2^19 x PE_U x (16M +- K)   
1319   2              = -----------------------------
1320   2                            Ths              
1321   2      
1322   2              = IHF x 2^19 x PE_U x (16M +- K)
1323   2      ****************************************************************************/
1324   2      // (M + K/16) = pllclock / 1024
1325   2      // 16M + K = 16 * pllclock / 1024
1326   2      // 2^19 * 2^4 / 2^10 = 2^13
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 23  

1327   2      // _PE_VALUE UNIT is ps, so result has to multiply 10^(-12)
1328   2      // stModeInfo.IHFreq/10 UNIT is KHz, so result has to multiply 10^2
1329   2          /*
1330   2              icode = (DWORD)((stModeInfo.IHFreq) * usPEValue * pllclock) / (DWORD)1220702;
1331   2              icode &= 0x00007fff;
1332   2              CScalerSetByte(_P1_I_CODE_M_A1,(BYTE)(icode >> 8));
1333   2              CScalerSetByte(_P1_I_CODE_L_A2, (BYTE)icode);
1334   2              // Set the P code
1335   2              pcode = (7 * icode * _RTD_XTAL / stModeInfo.IHFreq /_APLL_N_CODE) >> 7;
1336   2          //    pcode = 0xC0;
1337   2          //*/
1338   2          ///*    whhsiao 20080227 update-start
1339   2              icode = (DWORD)((stModeInfo.IHFreq) * usPEValue * pllclock) / (DWORD)1220703;
1340   2              //icode = icode>>2;   // n=32
1341   2              icode = icode>>6;   // n=512
1342   2              icode &= 0x00007fff;
1343   2          
1344   2              CScalerSetByte(_P1_I_CODE_M_A1,(BYTE)(icode >> 8));
1345   2              CScalerSetByte(_P1_I_CODE_L_A2, (BYTE)icode);
1346   2          
1347   2              // Set the P code
1348   2              //pcode = (5 * icode * _RTD_XTAL / (stModeInfo.IHFreq/10) / _APLL_N_CODE ) >> 7;    // Total gain=
             -(1+5)/32
1349   2              pcode = (63 * icode * _RTD_XTAL / (stModeInfo.IHFreq/10) / _APLL_N_CODE ) >> 7;    // Total gain=(
             -1+63)/512
1350   2          //    pcode = 0xC0;
1351   2          //*/    whhsiao 20080227 update-end
1352   2              if(pcode > 255)
1353   2              {
1354   3                      for(pData[0] = 9; pData[0] < 15; pData[0]++)
1355   3                      {
1356   4                              if((pcode >> pData[0]) == 0)
1357   4                                      break;
1358   4                      }
1359   3                  switch(pData[0]-9)//yc 20080225 
1360   3                  {
1361   4                      case 0:
1362   4                              pcode = pcode / _G_VALUE_DIVIDER_0;
1363   4                          break;
1364   4                      case 1:
1365   4                              pcode = pcode / _G_VALUE_DIVIDER_1;
1366   4                          break;
1367   4                      case 2:
1368   4                              pcode = pcode / _G_VALUE_DIVIDER_2;
1369   4                          break;
1370   4                      case 3:
1371   4                              pcode = pcode / _G_VALUE_DIVIDER_3;
1372   4                          break;
1373   4                      case 4:
1374   4                              pcode = pcode / _G_VALUE_DIVIDER_4;
1375   4                          break;
1376   4                      case 5:
1377   4                              pcode = pcode / _G_VALUE_DIVIDER_5;
1378   4                          break;
1379   4                      default:
1380   4                          break;
1381   4                  }
1382   3                      //pcode = pcode / g_value_divider[(pData[0] - 9)];
1383   3                      STemp = pData[0] - 7;
1384   3              }
1385   2          
1386   2              if(pcode==0)
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 24  

1387   2              pcode = 1;
1388   2          
1389   2              //g_value = 0x01;
1390   2              CScalerSetByte(_P1_P_CODE_MAPPING_METHOD_B6, STemp << 2);
1391   2          
1392   2              CScalerSetByte(_P1_DDS_MIX_2_B9, 0x05); //set the P_code_max
1393   2              CScalerSetByte(_P1_DDS_MIX_3_BA, 0x1e);
1394   2              CScalerSetByte(_P1_P_CODE_A3, (BYTE)pcode);
1395   2          
1396   2              CScalerSetByte(_P1_PLLPHASE_CTRL1_B4, 0x00);
1397   2          
1398   2              CTimerWaitForEvent(_EVENT_IEN_STOP);
1399   2              CTimerWaitForEvent(_EVENT_IEN_STOP);
1400   2          
1401   2              pData[0] = 32;
1402   2              do
1403   2              {
1404   3                  CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
1405   3                  CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
1406   3                  CScalerSetByte(_P1_PLLPHASE_CTRL1_B4, 0x00);
1407   3          
1408   3                  CTimerWaitForEvent(_EVENT_IEN_STOP);
1409   3                  CTimerWaitForEvent(_EVENT_IEN_STOP);
1410   3          
1411   3              }while(CAdjustGetAPLLSetting(usClock) && --pData[0]);
1412   2          
1413   2              CPowerADCAPLLOn();
1414   2              
1415   2          
1416   2              CTimerWaitForEvent(_EVENT_IEN_STOP);
1417   2              CTimerWaitForEvent(_EVENT_IEN_STOP);
1418   2              CTimerWaitForEvent(_EVENT_IEN_STOP);
1419   2          
1420   2              CAdjustGetAPLLSetting(usClock);
1421   2          
1422   2              CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x00);
1423   2          
1424   2              CMiscClearStatusRegister();
1425   2      
1426   2          }
1427   1      }
1428          
1429          void CAdjustAPLLFastLock(WORD usClock)
1430          {
1431   1          DWORD delta, pll_divider , pll_divider_k , pllclock , pll_divider_old ;
1432   1          BYTE mcode ;
1433   1          SBYTE kcode , delta_k , final_k , delta_m=0;
1434   1          DWORD sum_i_now;
1435   1          ///*    whhsiao 20080227 update-start
1436   1          SDWORD sum_i_now_temp[2]={0,0};
1437   1          BYTE  times;
1438   1          //*/    whhsiao 20080227 update-end
1439   1      
1440   1              //ADC sampling clock, UNIT in KHz
1441   1              pllclock = (DWORD)stModeInfo.IHFreq * usClock / 10;
1442   1          mcode = pllclock < 100000 ? 4 : 2;
1443   1          //Get (M + K/16) * 1024
1444   1          pll_divider_old  = (((pllclock * _APLL_N_CODE * mcode) << 10 ) / _RTD_XTAL) << 3;
1445   1          CScalerPageSelect(_PAGE1);
1446   1      /*
1447   1          CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x04);
1448   1          CTimerDelayXms(1);
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 25  

1449   1          CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x03);
1450   1          CScalerRead(_P1_FAST_PLL_ISUM_AB, 4, pData, _NON_AUTOINC);
1451   1      
1452   1          sum_i_now = ( (((DWORD)pData[0]<<24)&0x7000000) | (((DWORD)pData[1]<<16)&0xff0000)| (((DWORD)pData[2]<
             -<8)&0xff00) | ((DWORD)pData[3]&0xff)) ;
1453   1      */
1454   1      ///*    whhsiao 20080227 update-start
1455   1          for (times=0;times<10;times++)
1456   1          {
1457   2          CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x04);
1458   2          CTimerDelayXms(1);
1459   2          CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x03);
1460   2          CScalerRead(_P1_FAST_PLL_ISUM_AB, 4, pData, _NON_AUTOINC);
1461   2      
1462   2          sum_i_now_temp[1] = ( (((DWORD)pData[0]<<24)&0x7000000) | (((DWORD)pData[1]<<16)&0xff0000)| (((DWORD)p
             -Data[2]<<8)&0xff00) | ((DWORD)pData[3]&0xff)) ;
1463   2      
1464   2          if ((sum_i_now_temp[1]>>26) ==1)
1465   2              sum_i_now_temp[1] = sum_i_now_temp[1] | 0xF8000000;
1466   2      
1467   2          sum_i_now_temp[0] += sum_i_now_temp[1];
1468   2          CTimerDelayXms(1);
1469   2          }
1470   1      
1471   1          if ( (sum_i_now_temp[0]>>31) == 1)
1472   1              sum_i_now = ((sum_i_now_temp[0]/(SBYTE)10)^0xFFFFFFFF)+1;
1473   1          else
1474   1              sum_i_now = sum_i_now_temp[0]/(SBYTE)10;
1475   1      //*/    whhsiao 20080227 update-end
1476   1      
1477   1      
1478   1          // calculate Final K Value    
1479   1          delta_k =  sum_i_now >> 22;
1480   1      
1481   1          if ( (delta_k>>4) == 1 )
1482   1          {  
1483   2            delta_k |= 0xE0;
1484   2            delta_k +=1;
1485   2           }
1486   1      
1487   1          CScalerRead(0xAD, 1, pData, _NON_AUTOINC);
1488   1          kcode = (pData[0]>>4)&0x0f;
1489   1      
1490   1          if ( (kcode>>3) == 1 )
1491   1              kcode |= 0xF0;
1492   1      
1493   1          final_k = delta_k + kcode ;
1494   1      
1495   1      
1496   1          if (final_k < -16)
1497   1          {
1498   2              delta_m = -1;
1499   2              final_k +=16;
1500   2          }
1501   1          else if (final_k >15)
1502   1          {
1503   2              delta_m =1 ;
1504   2              final_k -=16;
1505   2          }
1506   1      
1507   1          
1508   1          final_k &= 0x0F;
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 26  

1509   1      
1510   1          // calculate Sum_I
1511   1          delta = sum_i_now & 0x3fffff;   // 22bits
1512   1      
1513   1      
1514   1          // calculate Final M Value 
1515   1          CScalerRead(0xAC, 1, pData, _NON_AUTOINC);
1516   1          mcode = pData[0]+3;
1517   1      
1518   1          if (delta_m>0)
1519   1              mcode += 1;
1520   1          if (delta_m<0)
1521   1              mcode -= 1;
1522   1      
1523   1          pll_divider = (DWORD)mcode << 26;
1524   1      
1525   1          pll_divider_k = (DWORD)final_k << 22;
1526   1      
1527   1      
1528   1          if ( (final_k>>3) == 1 )                                 // final_k 2's 
1529   1              pll_divider_k = 0x4000000 - pll_divider_k;
1530   1      
1531   1      
1532   1          if ( (final_k>>3) == 1 )
1533   1              pll_divider =  pll_divider - pll_divider_k ;
1534   1          else
1535   1              pll_divider =  pll_divider + pll_divider_k ;
1536   1      
1537   1      
1538   1          if ((sum_i_now>>26) ==1)                        // delta 2's
1539   1              delta = 0x400000 -  delta;       
1540   1        //  else
1541   1        //      delta = delta;
1542   1      
1543   1              
1544   1          if ((sum_i_now>>26) ==1)
1545   1              pll_divider = pll_divider - delta ;
1546   1          else
1547   1              pll_divider = pll_divider + delta ;
1548   1      
1549   1      
1550   1          usPllDivider =  pll_divider / usClock ;
1551   1          usPllDividerRem =  ((pll_divider % usClock) <<12) / usClock ;
1552   1      
1553   1          usIHFreqApllFast =  ((((DWORD)stModeInfo.IHFreq * (pll_divider>>11)) / pll_divider_old) + 2) >> 2;
1554   1        
1555   1      }
1556          //--------------------------------------------------
1557          // Description  : Set ADC clock (IHTotal)
1558          // Input Value  : usClock   --> Target ADC clock
1559          // Output Value : None
1560          //--------------------------------------------------
1561          void CAdjustAdcClock_OSD(WORD usClock)
1562          {
1563   1          DWORD delta, pll_divider;
1564   1          BYTE mcode;
1565   1          WORD pcode;
1566   1              SBYTE STemp ;
1567   1          CScalerPageSelect(_PAGE1);
1568   1      #if(_APLL_FAST_LOCK)
1569   1              //set the FAST PLL CONTROL
1570   1              CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT5 | _BIT1), (_BIT5 | _BIT1));
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 27  

1571   1      #endif
1572   1          pll_divider = ((usPllDivider * usClock)) + ((usPllDividerRem * usClock)>>12);
1573   1          mcode = pll_divider >> 26;
1574   1          STemp = (pll_divider>>22) & 0x0F;
1575   1              if(STemp>7)
1576   1              {
1577   2                      mcode +=1;
1578   2                      STemp -= 16;
1579   2              }
1580   1              else if(STemp<(-8))  // Always False
1581   1              {
1582   2                      mcode -=1;
1583   2                      STemp += 16;
1584   2              }
1585   1          delta = pll_divider & 0x003FFFFF;
1586   1              CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
1587   1              CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
1588   1              CScalerSetByte(_P1_PLL_M_AC, (mcode - 3)); 
1589   1              CScalerSetBit(_P1_PLL_N_AD, 0x0f, (((STemp & 0x0f) << 4) | (_APLL_N_CODE - 2)));
1590   1          pData[0] = 0x00;
1591   1              pData[1] = (BYTE)((delta >> 16) & 0x0000003f);
1592   1              pData[2] = (BYTE)((delta >> 8)  & 0x000000ff);
1593   1              pData[3] = (BYTE)((delta << 0)  & 0x000000ff);
1594   1              CScalerWrite(_P1_FAST_PLL_ISUM_AB, 4, pData, _NON_AUTOINC);
1595   1      /****************************************************************************
1596   1          PE Calibration Function  // Added by whhsiao 20080213
1597   1      ****************************************************************************/
1598   1          CScalerSetByte(0xA4, 0x80);
1599   1          CTimerDelayXms(1);
1600   1          CScalerRead(0xA4, 2, pData, _AUTOINC);
1601   1          usPEValue =  ( ((pData[0]&0x0F)<<8) | pData[1] );
1602   1          usPEValue = 1000000/(usPEValue*(_RTD_XTAL/1000));   // unit : ps
1603   1      /****************************************************************************
1604   1      
1605   1              Formula :
1606   1      
1607   1                I_gain       Ths                    PE(UNIT)                   1
1608   1              --------- x  ------- = ------------------------------------ x  -----
1609   1                 2^22        Tbck        Txclk x 16N/(16M +- K) x 1/16         8
1610   1      
1611   1                I_gain         Ths                      PE(UNIT)                   1
1612   1              --------- x  ----------- = ------------------------------------ x  -----
1613   1                 2^22       Tclk x N         Txclk x 16N/(16M +- K) x 1/16         8
1614   1      
1615   1                         2^22 x PE_U x (16M +- K)        1
1616   1              I_gain = ----------------------------- x -----
1617   1                                   Ths                   n
1618   1      
1619   1                  2^22 x PE_U x (16M +- K)        1
1620   1              = ----------------------------- x -----
1621   1                            Ths                   n
1622   1      
1623   1              = IHF x 2^22 x PE_U x (16M +- K) x 2^(-n)
1624   1      
1625   1      ****************************************************************************/
1626   1              // (M + K/16) = pllclock / 1024
1627   1              // 16M + K = 16 * pllclock / 1024
1628   1              // 2^19 * 2^4 / 2^10 = 2^13
1629   1              // _PE_VALUE UNIT is ps, so result has to multiply 10^(-12)
1630   1              // stModeInfo.IHFreq/10 UNIT is KHz, so result has to multiply 10^2
1631   1          pll_divider = (usPEValue * (usIHFreqApllFast/10)) * (pll_divider/(DWORD)100000);  //yc 20080306 
1632   1          pll_divider = (pll_divider/10000) >> 9;    // 
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 28  

1633   1          //pll_divider = (pll_divider/10000) >> 8;    // 
1634   1          pll_divider &= 0x00007fff;
1635   1              CScalerSetByte(_P1_I_CODE_M_A1,(BYTE)(pll_divider >> 8));
1636   1              CScalerSetByte(_P1_I_CODE_L_A2, (BYTE)pll_divider);
1637   1              // Set the P code
1638   1              pcode = (WORD) ((63*pll_divider * (_RTD_XTAL/_APLL_N_CODE) / (usIHFreqApllFast/10) ) >> 7); // Total Gain
             - = 65/512
1639   1          STemp=1;
1640   1              if(pcode > 255)
1641   1              {
1642   2                      for(pData[0] = 9; pData[0] < 15; pData[0]++)
1643   2                      {
1644   3                              if((pcode >> pData[0]) == 0)
1645   3                                      break;
1646   3                      }
1647   2              switch(pData[0]-9)//yc 20080225 
1648   2              {
1649   3                  case 0:
1650   3                              pcode = pcode / _G_VALUE_DIVIDER_0;
1651   3                      break;
1652   3                  case 1:
1653   3                              pcode = pcode / _G_VALUE_DIVIDER_1;
1654   3                      break;
1655   3                  case 2:
1656   3                              pcode = pcode / _G_VALUE_DIVIDER_2;
1657   3                      break;
1658   3                  case 3:
1659   3                              pcode = pcode / _G_VALUE_DIVIDER_3;
1660   3                      break;
1661   3                  case 4:
1662   3                              pcode = pcode / _G_VALUE_DIVIDER_4;
1663   3                      break;
1664   3                  case 5:
1665   3                              pcode = pcode / _G_VALUE_DIVIDER_5;
1666   3                      break;
1667   3                  default:
1668   3                      break;
1669   3              }
1670   2                      STemp = pData[0] - 7;
1671   2              }
1672   1          if(pcode==0x00)
1673   1              pcode = 0x01;
1674   1              CScalerSetByte(_P1_P_CODE_MAPPING_METHOD_B6, STemp << 2);
1675   1          CScalerSetByte(_P1_DDS_MIX_2_B9, 0xFF); //set the P_code_max
1676   1          CScalerSetByte(_P1_DDS_MIX_3_BA, 0xFF);
1677   1              CScalerSetByte(_P1_P_CODE_A3, (BYTE)pcode); 
1678   1      #if(_APLL_FAST_LOCK) //yc 20080225
1679   1          //CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT6 | _BIT5 | _BIT4), (_BIT6 | _BIT5 | _BIT4));
1680   1          CAdjustDisableWatchDog(_WD_APLL_NONLOCK);
1681   1          CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT6 | _BIT5), (_BIT6 | _BIT5));
1682   1          CTimerDelayXms(100); 
1683   1          CAdjustEnableWatchDog(_WD_APLL_NONLOCK);
1684   1      #else
                  //Enable Double buffer write in PLL M/N K¡BPLLDIV¡BDDS SUM_I
                      CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~_BIT4, _BIT4);
              #endif
1688   1          CMiscClearStatusRegister();
1689   1      }
1690          
1691          // Eric 0617 add for YPbPr
1692          void CAdjustAdcClockYPbPr(WORD usClock)
1693          {
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 29  

1694   1          //#define _PE_VALUE   175 // Unit: ps
1695   1          DWORD pllclock, icode, SUM_I;
1696   1          BYTE mcode;
1697   1          SBYTE kcode,g_value = 1;
1698   1          WORD delta, pcode;
1699   1          static BYTE vco_divider = 2;
1700   1          BYTE g_value_divider[6] = {4, 16, 64, 128, 256, 512};
1701   1      #if     (_APLL_FAST_LOCK)
1702   1          DWORD temp2662;
1703   1      #endif
1704   1      
1705   1      
1706   1              if(bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
1707   1              CAdjustEnableWatchDog(_WD_DV_TIMEOUT);
1708   1          CScalerPageSelect(_PAGE1);
1709   1      
1710   1      #if(_APLL_FAST_LOCK)
1711   1              //set the FAST PLL CONTROL
1712   1              CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT5 | _BIT1), (_BIT5 | _BIT1));
1713   1      #endif
1714   1          /********************************************************
1715   1          Fvco : Frequency of APLL
1716   1          Fxtal : Frequency of Crystal
1717   1          IHF : Input Horizontal Frequency
1718   1          usClock : Divider number of input clock
1719   1          stModeInfo.IHFreq = 10 * IHF(in KHz)
1720   1          _RTD_XTAl : Defined crystal clock unit in KHz
1721   1      
1722   1          Fvco = Fxtal*(M + K/16)/N1 = IHF * usClock * vco_divider
1723   1          Assum N1 = 2
1724   1          (M + K/16) = IHF * usClock * N1 * vco_divider / Fxtal
1725   1          stModeInfo.IHFreq UINT in 100Hz
1726   1          *********************************************************/
1727   1      
1728   1          //ADC sampling clock, UNIT in KHz
1729   1          pllclock = (DWORD)stModeInfo.IHFreq * usClock / 10;
1730   1      
1731   1          vco_divider = pllclock < 100000 ? 4 : 2;
1732   1      
1733   1          //Get (M + K/16) * 1024
1734   1          pllclock  = ((((pllclock * _APLL_N_CODE * vco_divider) << 4 )/(DWORD)(_RTD_XTAL)) << 6);
1735   1      
1736   1          CScalerPageSelect(_PAGE1);
1737   1          CScalerSetByte(_P1_PLL_DIV_CTRL_A0, 0x08);
1738   1      //  CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x24);  //Ming-Yen
1739   1      //  CScalerSetByte(_P1_PE_TRACKING_METHOD_B7, 0x02); //Ming-Yen
1740   1      //  CScalerSetByte(_P1_DDS_MIX_1_B8, 0x0c);   //Ming-Yen
1741   1          CScalerSetByte(_P1_DDS_MIX_2_B9, 0xff);
1742   1          CScalerSetByte(_P1_PLL_CRNT_AE, 0x63);
1743   1          
1744   1          //CScalerSetByte(_P1_PLL_WD_AF, 0x08);
1745   1      
1746   1          CScalerSetBit(_P1_PLLDIV_H_B1, ~(_BIT6 | _BIT5 | _BIT4), (vco_divider == 2) ? (_BIT6 | _BIT5) : (_BIT6
             - | _BIT5 | _BIT4));
1747   1      
1748   1             
1749   1      
1750   1          //Set the divide number
1751   1          CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
1752   1          CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
1753   1      
1754   1      
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 30  

1755   1      ////////////////////////////////////////
1756   1            CAdjustGetAPLLSetting(usClock);
1757   1      ////////////////////////////////////////
1758   1      
1759   1      
1760   1          //Set N code
1761   1          CScalerSetBit(_P1_PLL_N_AD, 0xf8, ((_APLL_N_CODE - 2) & 0x07));
1762   1      
1763   1          //Get M, K code, M + K/16 = pllclock / 1024
1764   1          mcode = pllclock >> 10; //M is the integer part
1765   1          delta = (DWORD)pllclock - ((DWORD)mcode << 10);
1766   1      
1767   1          //K is the fraction part quantized by 16
1768   1          kcode = (delta) >> 6; 
1769   1      
1770   1      #if(_APLL_FAST_LOCK)
1771   1          //SUM_I is the truncated part by calculation quantized by 1024
1772   1              SUM_I = ((DWORD)delta << 4) - ((DWORD)kcode << 10); 
1773   1      #endif  
1774   1      
1775   1          //K is range from -8 ~ 7
1776   1          if(kcode>7)
1777   1          {
1778   2              mcode +=1;
1779   2              kcode -= 16;
1780   2          }
1781   1          else if(kcode<(-8))
1782   1          {
1783   2              mcode -=1;
1784   2              kcode += 16;
1785   2          }
1786   1      
1787   1          //set M, N, K code
1788   1          CScalerSetByte(_P1_PLL_M_AC, (mcode - 3)); 
1789   1          CScalerSetBit(_P1_PLL_N_AD, 0x0f, (((kcode & 0x0f) << 4) | (_APLL_N_CODE - 2)));
1790   1      
1791   1      #if (_APLL_FAST_LOCK)
1792   1              SUM_I = SUM_I << 12; // over flow need to modify
1793   1          //set SUM_I
1794   1              temp2662 = SUM_I & 0x07ffffff;
1795   1              pData[0] = (BYTE)((temp2662 >>24) & 0x000000ff);
1796   1              pData[1] = (BYTE)((temp2662 >>16) & 0x000000ff);
1797   1              pData[2] = (BYTE)((temp2662 >>8) & 0x000000ff);
1798   1              pData[3] = (BYTE)(temp2662 & 0x000000ff);
1799   1              CScalerWrite(_P1_FAST_PLL_ISUM_AB, 4, pData, _NON_AUTOINC);
1800   1      #endif
1801   1      
1802   1      
1803   1      /****************************************************************************
1804   1      
1805   1          Formula :
1806   1      
1807   1            I_gain       Ths                    PE(UNIT)                   1
1808   1          --------- x  ------- = ------------------------------------ x  -----
1809   1             2^22        Tbck        Txclk x 16N/(16M +- K) x 1/16         8
1810   1      
1811   1            I_gain         Ths                      PE(UNIT)                   1
1812   1          --------- x  ----------- = ------------------------------------ x  -----
1813   1             2^22       Tclk x N         Txclk x 16N/(16M +- K) x 1/16         8
1814   1      
1815   1                     2^22 x PE_U x (16M +- K)        1
1816   1          I_gain = ----------------------------- x -----
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 31  

1817   1                               Ths                   8
1818   1      
1819   1              2^19 x PE_U x (16M +- K)
1820   1          = -----------------------------
1821   1                        Ths
1822   1      
1823   1          = IHF x 2^19 x PE_U x (16M +- K)
1824   1      
1825   1      ****************************************************************************/
1826   1      
1827   1          // (M + K/16) = pllclock / 1024
1828   1          // 16M + K = 16 * pllclock / 1024
1829   1          // 2^19 * 2^4 / 2^10 = 2^13
1830   1          // _PE_VALUE UNIT is ps, so result has to multiply 10^(-12)
1831   1          // stModeInfo.IHFreq/10 UNIT is KHz, so result has to multiply 10^2
1832   1      
1833   1          icode = (DWORD)((stModeInfo.IHFreq) * 120/*usPEValue*/ * pllclock)/(DWORD)1220702;
1834   1          icode &= 0x00007fff;
1835   1      
1836   1          CScalerSetByte(_P1_I_CODE_M_A1,(BYTE)(icode >> 8));
1837   1          CScalerSetByte(_P1_I_CODE_L_A2, (BYTE)icode);
1838   1      
1839   1          // Set the P code
1840   1          pcode = (7 * icode * _RTD_XTAL / stModeInfo.IHFreq /_APLL_N_CODE) >> 7;
1841   1          
1842   1          if(pcode > 255)
1843   1          {
1844   2              for(pData[0] = 9; pData[0] < 15; pData[0]++)
1845   2              {
1846   3                  if((pcode >> pData[0]) == 0)
1847   3                      break;
1848   3              }
1849   2              pcode = pcode / g_value_divider[(pData[0] - 9)];
1850   2              g_value = pData[0] - 7;
1851   2          }
1852   1      
1853   1          CScalerSetByte(_P1_P_CODE_MAPPING_METHOD_B6, g_value << 2);
1854   1          CScalerSetByte(_P1_DDS_MIX_2_B9, 0x05); //set the P_code_max
1855   1          CScalerSetByte(_P1_DDS_MIX_3_BA, 0x1e);
1856   1          CScalerSetByte(_P1_P_CODE_A3, (BYTE)pcode);
1857   1      
1858   1      #if (_APLL_FAST_LOCK)
1859   1              //CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x60);
1860   1              CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT6 | _BIT5 | _BIT3), (_BIT6 | _BIT5 | _BIT3));
1861   1      #else
                  //Enable Double buffer write in PLL M/N K¡BPLLDIV¡BDDS SUM_I
                      CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~_BIT4, _BIT4);
              #endif
1865   1      
1866   1          CScalerSetByte(_P1_PLLPHASE_CTRL1_B4, 0x00);
1867   1      
1868   1          CTimerWaitForEvent(_EVENT_IEN_STOP);
1869   1          CTimerWaitForEvent(_EVENT_IEN_STOP);
1870   1      
1871   1          pData[0] = 32;
1872   1          do
1873   1          {
1874   2              CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
1875   2              CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
1876   2              CScalerSetByte(_P1_PLLPHASE_CTRL1_B4, 0x00);
1877   2      
1878   2           //   CTimerWaitForEvent(_EVENT_IEN_STOP);
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 32  

1879   2             // CTimerWaitForEvent(_EVENT_IEN_STOP);
1880   2      
1881   2          }while(CAdjustGetAPLLSetting(usClock) && --pData[0]);
1882   1      
1883   1          CPowerADCAPLLOn();
1884   1          //DebugPrintf("\n CPowerADCAPLLOn ... ",0x20);
1885   1          
1886   1          CTimerWaitForEvent(_EVENT_IEN_STOP);
1887   1          CTimerWaitForEvent(_EVENT_IEN_STOP);
1888   1          CTimerWaitForEvent(_EVENT_IEN_STOP);
1889   1              
1890   1          CAdjustGetAPLLSetting(usClock);
1891   1              
1892   1          CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x00);
1893   1              
1894   1          CMiscClearStatusRegister();
1895   1              
1896   1              if (bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
1897   1             CAdjustEnableWatchDog(_WD_ALL);
1898   1      }
1899          
1900          #else
              
              //--------------------------------------------------
              // Description  : Set ADC clock (IHTotal)
              // Input Value  : usClock   --> Target ADC clock
              // Output Value : None
              //--------------------------------------------------
              void CAdjustAdcClock(WORD usClock)
              {
                  //#define _PE_VALUE   175 // Unit: ps
                  DWORD pllclock, icode, SUM_I;
                  BYTE mcode;
                  SBYTE kcode,g_value = 1;
                  WORD delta, pcode;
                  static BYTE vco_divider = 2;
                  BYTE g_value_divider[6] = {4, 16, 64, 128, 256, 512};
              #if     (_APLL_FAST_LOCK)
                  DWORD temp2662;
              #endif
              
              
                      if(bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
                      CAdjustEnableWatchDog(_WD_DV_TIMEOUT);
                  CScalerPageSelect(_PAGE1);
              
              #if(_APLL_FAST_LOCK)
                      //set the FAST PLL CONTROL
                      CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT5 | _BIT1), (_BIT5 | _BIT1));
              #endif
                  /********************************************************
                  Fvco : Frequency of APLL
                  Fxtal : Frequency of Crystal
                  IHF : Input Horizontal Frequency
                  usClock : Divider number of input clock
                  stModeInfo.IHFreq = 10 * IHF(in KHz)
                  _RTD_XTAl : Defined crystal clock unit in KHz
              
                  Fvco = Fxtal*(M + K/16)/N1 = IHF * usClock * vco_divider
                  Assum N1 = 2
                  (M + K/16) = IHF * usClock * N1 * vco_divider / Fxtal
                  stModeInfo.IHFreq UINT in 100Hz
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 33  

                  *********************************************************/
              
                  //ADC sampling clock, UNIT in KHz
                  pllclock = (DWORD)stModeInfo.IHFreq * usClock / 10;
              
                  vco_divider = pllclock < 100000 ? 4 : 2;
              
                  //Get (M + K/16) * 1024
                  pllclock  = ((((pllclock * _APLL_N_CODE * vco_divider) << 4 )/(DWORD)(_RTD_XTAL)) << 6);
              
                  CScalerPageSelect(_PAGE1);
                  CScalerSetByte(_P1_PLL_DIV_CTRL_A0, 0x08);
              //  CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x24);  //Ming-Yen
              //  CScalerSetByte(_P1_PE_TRACKING_METHOD_B7, 0x02); //Ming-Yen
              //  CScalerSetByte(_P1_DDS_MIX_1_B8, 0x0c);   //Ming-Yen
                  CScalerSetByte(_P1_DDS_MIX_2_B9, 0xff);
                  CScalerSetByte(_P1_PLL_CRNT_AE, 0x63);
                  
                  //CScalerSetByte(_P1_PLL_WD_AF, 0x08);
              
                  CScalerSetBit(_P1_PLLDIV_H_B1, ~(_BIT6 | _BIT5 | _BIT4), (vco_divider == 2) ? (_BIT6 | _BIT5) : (_BIT6
             - | _BIT5 | _BIT4));
              
                     
              
                  //Set the divide number
                  CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
                  CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
              
              
              ////////////////////////////////////////
                    CAdjustGetAPLLSetting(usClock);
              ////////////////////////////////////////
              
              
                  //Set N code
                  CScalerSetBit(_P1_PLL_N_AD, 0xf8, ((_APLL_N_CODE - 2) & 0x07));
              
                  //Get M, K code, M + K/16 = pllclock / 1024
                  mcode = pllclock >> 10; //M is the integer part
                  delta = (DWORD)pllclock - ((DWORD)mcode << 10);
              
                  //K is the fraction part quantized by 16
                  kcode = (delta) >> 6; 
              
              #if(_APLL_FAST_LOCK)
                  //SUM_I is the truncated part by calculation quantized by 1024
                      SUM_I = ((DWORD)delta << 4) - ((DWORD)kcode << 10); 
              #endif  
              
                  //K is range from -8 ~ 7
                  if(kcode>7)
                  {
                      mcode +=1;
                      kcode -= 16;
                  }
                  else if(kcode<(-8))
                  {
                      mcode -=1;
                      kcode += 16;
                  }
              
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 34  

                  //set M, N, K code
                  CScalerSetByte(_P1_PLL_M_AC, (mcode - 3)); 
                  CScalerSetBit(_P1_PLL_N_AD, 0x0f, (((kcode & 0x0f) << 4) | (_APLL_N_CODE - 2)));
              
              #if (_APLL_FAST_LOCK)
                      SUM_I = SUM_I << 12; // over flow need to modify
                  //set SUM_I
                      temp2662 = SUM_I & 0x07ffffff;
                      pData[0] = (BYTE)((temp2662 >>24) & 0x000000ff);
                      pData[1] = (BYTE)((temp2662 >>16) & 0x000000ff);
                      pData[2] = (BYTE)((temp2662 >>8) & 0x000000ff);
                      pData[3] = (BYTE)(temp2662 & 0x000000ff);
                      CScalerWrite(_P1_FAST_PLL_ISUM_AB, 4, pData, _NON_AUTOINC);
              #endif
              
              
              /****************************************************************************
              
                  Formula :
              
                    I_gain       Ths                    PE(UNIT)                   1
                  --------- x  ------- = ------------------------------------ x  -----
                     2^22        Tbck        Txclk x 16N/(16M +- K) x 1/16         8
              
                    I_gain         Ths                      PE(UNIT)                   1
                  --------- x  ----------- = ------------------------------------ x  -----
                     2^22       Tclk x N         Txclk x 16N/(16M +- K) x 1/16         8
              
                             2^22 x PE_U x (16M +- K)        1
                  I_gain = ----------------------------- x -----
                                       Ths                   8
              
                      2^19 x PE_U x (16M +- K)
                  = -----------------------------
                                Ths
              
                  = IHF x 2^19 x PE_U x (16M +- K)
              
              ****************************************************************************/
              
                  // (M + K/16) = pllclock / 1024
                  // 16M + K = 16 * pllclock / 1024
                  // 2^19 * 2^4 / 2^10 = 2^13
                  // _PE_VALUE UNIT is ps, so result has to multiply 10^(-12)
                  // stModeInfo.IHFreq/10 UNIT is KHz, so result has to multiply 10^2
              
                  icode = (DWORD)((stModeInfo.IHFreq) * 120/*usPEValue*/ * pllclock)/(DWORD)1220702;
                  icode &= 0x00007fff;
              
                  CScalerSetByte(_P1_I_CODE_M_A1,(BYTE)(icode >> 8));
                  CScalerSetByte(_P1_I_CODE_L_A2, (BYTE)icode);
              
                  // Set the P code
                  pcode = (7 * icode * _RTD_XTAL / stModeInfo.IHFreq /_APLL_N_CODE) >> 7;
                  
                  if(pcode > 255)
                  {
                      for(pData[0] = 9; pData[0] < 15; pData[0]++)
                      {
                          if((pcode >> pData[0]) == 0)
                              break;
                      }
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 35  

                      pcode = pcode / g_value_divider[(pData[0] - 9)];
                      g_value = pData[0] - 7;
                  }
              
                  CScalerSetByte(_P1_P_CODE_MAPPING_METHOD_B6, g_value << 2);
                  CScalerSetByte(_P1_DDS_MIX_2_B9, 0x05); //set the P_code_max
                  CScalerSetByte(_P1_DDS_MIX_3_BA, 0x1e);
                  CScalerSetByte(_P1_P_CODE_A3, (BYTE)pcode);
              
              #if (_APLL_FAST_LOCK)
                      //CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x60);
                      CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT6 | _BIT5 | _BIT3), (_BIT6 | _BIT5 | _BIT3));
              #else
                  //Enable Double buffer write in PLL M/N K¡BPLLDIV¡BDDS SUM_I
                      CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~_BIT4, _BIT4);
              #endif
              
                  CScalerSetByte(_P1_PLLPHASE_CTRL1_B4, 0x00);
              
                  CTimerWaitForEvent(_EVENT_IEN_STOP);
                  CTimerWaitForEvent(_EVENT_IEN_STOP);
              
                  pData[0] = 32;
                  do
                  {
                      CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
                      CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
                      CScalerSetByte(_P1_PLLPHASE_CTRL1_B4, 0x00);
              
                   //   CTimerWaitForEvent(_EVENT_IEN_STOP);
                     // CTimerWaitForEvent(_EVENT_IEN_STOP);
              
                  }while(CAdjustGetAPLLSetting(usClock) && --pData[0]);
              
                  CPowerADCAPLLOn();
                  //DebugPrintf("\n CPowerADCAPLLOn ... ",0x20);
                  
                  CTimerWaitForEvent(_EVENT_IEN_STOP);
                  CTimerWaitForEvent(_EVENT_IEN_STOP);
                  CTimerWaitForEvent(_EVENT_IEN_STOP);
                      
                  CAdjustGetAPLLSetting(usClock);
                      
                  CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x00);
                      
                  CMiscClearStatusRegister();
                      
                      if (bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
                     CAdjustEnableWatchDog(_WD_ALL);
              }
              
              #endif
2116          
2117          
2118          //--------------------------------------------------
2119          // Description  : Get APLL Setting
2120          // Input Value  : usClock   --> Target ADC clock
2121          // Output Value : None
2122          //--------------------------------------------------
2123          BYTE CAdjustGetAPLLSetting(WORD usClock)
2124          {
2125   1          BYTE ucTemp[2];
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 36  

2126   1      
2127   1              usClock -= 1;
2128   1          
2129   1          CScalerPageSelect(_PAGE1);
2130   1          CScalerRead(_P1_PLLDIV_H_B1, 2, ucTemp, _AUTOINC);
2131   1      
2132   1              ucTemp[0] &= 0x0f;
2133   1      
2134   1              if((ucTemp[0] != (BYTE)(usClock >> 8)) || (ucTemp[1] != (BYTE)(usClock & 0x00ff)))
2135   1              {
2136   2                      return _TRUE;
2137   2              }
2138   1              else
2139   1              {
2140   2                      return _FALSE;
2141   2              }
2142   1      }
2143          
2144          
2145          //--------------------------------------------------
2146          // Description  : Set phase
2147          // Input Value  : ucPhase   --> Target phase, ucPhase = N, N = 0 ~ 63
2148          // Output Value : None
2149          //--------------------------------------------------
2150          void CAdjustPhase(BYTE ucPhase)
2151          {
2152   1      #if(1)
2153   1          BYTE ctrl, select;
2154   1              //DebugPrintf("\n CAdjustPhase %c",'!');
2155   1              
2156   1              if (bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
2157   1             CAdjustEnableWatchDog(_WD_DV_TIMEOUT_APLL_NONLOCK);
2158   1      
2159   1              //Ida added for change range from 0-63 to 0-100
2160   1               ucPhase = ucPhase & 0x3f;
2161   1              //ucPhase = ((WORD)(ucPhase*64)/101) & 0x3f;
2162   1      
2163   1          // Code below is to select stable HSYNC latch edge.
2164   1          // There is about 2.025ns delay for RTD2553V between input clock into ADC and output from ADC.
2165   1          // Calculating the corresponding phase delay for 2.025ns
2166   1          // Original Formula :
2167   1              // select = 64 * 2.025 * ulRate / 1000000;
2168   1      
2169   1          //select = (DWORD)_RTD_XTAL * stModeInfo.IHTotal / stModeInfo.IHCount * 130 / 1000000;
2170   1          select = (DWORD)_RTD_XTAL * stModeInfo.IHTotal / stModeInfo.IHCount * 389 / 1000000;
2171   1      
2172   1          select = (select <= 64) ? (64 - select) : (128 - select);
2173   1      
2174   1          // Calculate the absolute value from the selected phase to transition
2175   1          pData[0]    = (ucPhase >= select) ? ucPhase - select : select - ucPhase;
2176   1          ctrl        = (pData[0] > 12 && pData[0] < 52) ? 0x00 : 0x01;
2177   1      
2178   1          if((stModeInfo.IHStartPos < stModeUserData.HPosition) && ((stModeUserData.HPosition - stModeInfo.IHSta
             -rtPos) > ucHStartBias))
2179   1              stModeUserData.HPosition = stModeInfo.IHStartPos + ucHStartBias;
2180   1      
2181   1          if((stModeInfo.IHStartPos > stModeUserData.HPosition) && ((stModeInfo.IHStartPos - stModeUserData.HPos
             -ition) > ucHStartBias))
2182   1              stModeUserData.HPosition = stModeInfo.IHStartPos - ucHStartBias;
2183   1      
2184   1      //    pData[0]    = ucHStartBias + stModeInfo.IHStartPos - stModeUserData.HPosition  + _PROGRAM_HDELAY;
2185   1          ((WORD *)pData)[0]  = ucHStartBias + stModeInfo.IHStartPos - stModeUserData.HPosition  + _PROGRAM_HDEL
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 37  

             -AY;
2186   1      
2187   1      
2188   1          // Compensate the H position shift due to the phase select
2189   1          if (select > 12)
2190   1              select  = ((ucPhase + 12) < select) ? (((WORD *)pData)[0] - 1) : ((WORD *)pData)[0];
2191   1          else
2192   1              select  = (ucPhase < (select + 52)) ? (((WORD *)pData)[0] - 1) : ((WORD *)pData)[0];
2193   1      
2194   1          CScalerPageSelect(_PAGE1);
2195   1      
2196   1          CScalerSetBit(_P1_PLLDIV_H_B1, ~_BIT6, _BIT6);
2197   1          if(((DWORD)stModeInfo.IHFreq * stModeInfo.IHTotal / 1000) < 530)
2198   1          {
2199   2              CScalerSetBit(_P1_PLLPHASE_CTRL1_B4, 0x80, ucPhase * 2);           // Set phase
2200   2          }
2201   1          else
2202   1          {
2203   2              CScalerSetBit(_P1_PLLPHASE_CTRL1_B4, 0x80, ucPhase);               // Set phase
2204   2          }
2205   1      
2206   1          CAdjustIHSDelay(select);                                        // Compensate IHS delay
2207   1          CScalerSetBit(_VGIP_DELAY_CTRL_12, ~_BIT3, (ctrl << 3));        // Select a correct edge to latch the 
             -stable data
2208   1          
2209   1          CMiscApplyDoubleBuffer();
2210   1                      
2211   1          CMiscClearStatusRegister();
2212   1              if (bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
2213   1             CAdjustEnableWatchDog(_WD_ALL);
2214   1      #else
                  BYTE ctrl, select;
                  BYTE pllclock;
                  //DebugPrintf("\n CAdjustPhase %c",'!');
                  
                  if(bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)  // for Aspect ratio,hill 20070515  
                  CAdjustEnableWatchDog(_WD_DV_TIMEOUT);
                  
                  //Ida added for change range from 0-63 to 0-100
                  ucPhase = ucPhase & 0x3f;
               
                  pllclock = (DWORD)stModeInfo.IHFreq * stModeUserData.Clock / 10000;
                  if(pllclock < 113)
                      select = (138+pllclock)/4;
                  else
                      select = (pllclock-113)/3;
               
               
                  // Calculate the absolute value from the selected phase to transition
                  pData[0]    = (ucPhase >= select) ? ucPhase - select : select - ucPhase;
                  ctrl = (pData[0] > 12 && pData[0] < 52) ? 0x00 : 0x01;
               
                  if((stModeInfo.IHStartPos < stModeUserData.HPosition) && ((stModeUserData.HPosition - stModeInfo.IHSta
             -rtPos) > ucHStartBias))
                      stModeUserData.HPosition = stModeInfo.IHStartPos + ucHStartBias;
               
                  if((stModeInfo.IHStartPos > stModeUserData.HPosition) && ((stModeInfo.IHStartPos - stModeUserData.HPos
             -ition) > ucHStartBias))
                      stModeUserData.HPosition = stModeInfo.IHStartPos - ucHStartBias;
               
              //    pData[0]    = ucHStartBias + stModeInfo.IHStartPos - stModeUserData.HPosition  + _PROGRAM_HDELAY;
                  ((WORD *)pData)[0]  = ucHStartBias + stModeInfo.IHStartPos - stModeUserData.HPosition  + _PROGRAM_HDEL
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 38  

             -AY;
               
              
                  // Compensate the H position shift due to the phase select
                  if (select > 12)
                      select  = ((ucPhase + 12) < select) ? (((WORD *)pData)[0] - 1) : ((WORD *)pData)[0];
                  else
                      select  = (ucPhase < (select + 52)) ? (((WORD *)pData)[0] - 1) : ((WORD *)pData)[0];
                  CScalerPageSelect(_PAGE1);
               
                  CScalerSetBit(_P1_PLLDIV_H_B1, ~_BIT6, _BIT6);
               
                  if((bit)CScalerGetBit(_P1_PLLDIV_H_B1, _BIT4))
                  {
                      CScalerSetBit(_P1_PLLPHASE_CTRL1_B4, 0x80, ucPhase * 2);           // Set phase
                  }
                  else
                  {
                      CScalerSetBit(_P1_PLLPHASE_CTRL1_B4, 0x80, ucPhase);               // Set phase
                  }
               
                  CAdjustIHSDelay(select);                                        // Compensate IHS delay
                  CScalerSetBit(_VGIP_DELAY_CTRL_12, ~_BIT3, (ctrl << 3));        // Select a correct edge to latch the 
             -stable data
                  
                  CMiscApplyDoubleBuffer();
                
                  CMiscClearStatusRegister();
                
                  if(bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)  // for Aspect ratio,hill 20070515  
                      CAdjustEnableWatchDog(_WD_DV_TIMEOUT | _WD_FRAMESYNC);
              #endif
2274   1      }
2275          
2276          //--------------------------------------------------
2277          // Description  : Set H Position
2278          // Input Value  : None
2279          // Output Value : None
2280          //--------------------------------------------------
2281          void CAdjustHPosition(void)
2282          {
2283   1          // Update IHS delay according to phase
2284   1          CAdjustPhase(stModeUserData.Phase);
2285   1      }
2286          
2287          //--------------------------------------------------
2288          // Description  : Set V Position
2289          // Input Value  : None
2290          // Output Value : None
2291          //--------------------------------------------------
2292          void CAdjustVPosition(void)
2293          {
2294   1              if (bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
2295   1             CAdjustEnableWatchDog(_WD_APLL_NONLOCK);
2296   1      
2297   1          if((stModeInfo.IVStartPos < stModeUserData.VPosition) && ((stModeUserData.VPosition - stModeInfo.IVSta
             -rtPos) > ucVStartBias))
2298   1          {
2299   2              stModeUserData.VPosition = stModeInfo.IVStartPos + ucVStartBias;
2300   2          }
2301   1      
2302   1              #if(_V_POSITION_DIRECTION == _V_POSITION_METHOD_0)
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 39  

2303   1          CAdjustIVSDelay(ucVStartBias + stModeInfo.IVStartPos - stModeUserData.VPosition + _PROGRAM_VDELAY);
2304   1              #endif
2305   1      
2306   1              #if(_V_POSITION_DIRECTION == _V_POSITION_METHOD_1)
                  CAdjustIVSDelay(ucVStartBias - (stModeInfo.IVStartPos - stModeUserData.VPosition) + _PROGRAM_VDELAY);
                      #endif
2309   1      
2310   1          CMiscApplyDoubleBuffer();
2311   1      
2312   1          CTimerWaitForEvent(_EVENT_DEN_STOP);
2313   1          CTimerWaitForEvent(_EVENT_DEN_START);
2314   1      
2315   1          CMiscClearStatusRegister();
2316   1              if (bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
2317   1             CAdjustEnableWatchDog(_WD_ALL);
2318   1      }
2319          
2320          //--------------------------------------------------
2321          // Description  : Adjust Digital Filter
2322          // Input Value  : None
2323          // Output Value : None
2324          //--------------------------------------------------
2325          void CAdjustDigitalFilter(BYTE ucAccess, BYTE ucOffset, BYTE ucDiv, BYTE ucEnable)
2326          {
2327   1          pData[0] = ((ucAccess & 0x0f) << 4) | 0x00;
2328   1      
2329   1          if(ucAccess == _YPBPR_ACCESS_PORT)
2330   1          {
2331   2              pData[1] = ((ucOffset & 0x07) << 5) | 0x10;
2332   2          }
2333   1          else
2334   1          {
2335   2              pData[1] = ((ucEnable & 0x01) << 7) | ((ucOffset & 0x07) << 4) | ((ucDiv & 0x03) << 2);
2336   2          }
2337   1      
2338   1          CScalerWrite(_DIGITAL_FILTER_CTRL_98, 2, pData, _AUTOINC);
2339   1      
2340   1          CScalerSetByte(_DIGITAL_FILTER_CTRL_98, 0x00);
2341   1      }
2342          
2343          void CAdjustSetYpbprRhue(void)
2344          {
2345   1              CScalerSetBit(_COLOR_CTRL_62, 0xc7, 0x08);
2346   1              CScalerWrite(_SRGB_ACCESS_PORT_63, 6, pData, _NON_AUTOINC);
2347   1      }
2348          
2349          void CAdjustSetYpbprGhue(void)
2350          {
2351   1              CScalerSetBit(_COLOR_CTRL_62, 0xc7, 0x10);
2352   1              CScalerWrite(_SRGB_ACCESS_PORT_63, 6, pData, _NON_AUTOINC);
2353   1      }
2354          
2355          void CAdjustSetYpbprBhue(void)
2356          {
2357   1              CScalerSetBit(_COLOR_CTRL_62, 0xc7 ,0x18);
2358   1              CScalerWrite(_SRGB_ACCESS_PORT_63, 6, pData, _NON_AUTOINC);
2359   1      }
2360          
2361          #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON) || (_YPBPR_SUPPORT == _ON))
2362          void CAdjustInterlaceIVS2DVSProtection(void)
2363          {
2364   1              WORD ustemp;
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 40  

2365   1              BYTE temp;
2366   1      
2367   1              CScalerRead(_IPV_ACT_LEN_H_1A, 1, pData, _NON_AUTOINC);
2368   1              if(pData[0] & 0x20)
2369   1              {
2370   2            //  CScalerSetBit(_SCALE_CTRL_32, ~(_BIT7 | _BIT6), _BIT7); //forster modified 061102 
2371   2              //CScalerSetBit(_VGIP_ODD_CTRL_13, ~_BIT0, _BIT0);
2372   2      
2373   2      //V400 modify
2374   2              CScalerRead(_IV_DV_DELAY_CLK_ODD_41, LENGTH(1), &temp, _NON_AUTOINC);
2375   2              ustemp = (WORD)temp * 16 + 16;
2376   2      
2377   2              if(ustemp > (stModeInfo.IHTotal / 2))
2378   2              {
2379   3                  ustemp -= stModeInfo.IHTotal / 2;
2380   3                  CScalerSetByte(_IV_DV_DELAY_CLK_EVEN_42, (ustemp - 16) / 16);
2381   3              }
2382   2              else
2383   2              {
2384   3                  CScalerSetByte(_IPV_ACT_STA_L_19, CScalerGetBit(_IPV_ACT_STA_L_19, 0xff) + 1);
2385   3                  ustemp += stModeInfo.IHTotal;
2386   3                  CScalerSetByte(_IV_DV_DELAY_CLK_ODD_41, (ustemp - 16) / 16);
2387   3                  ustemp -= stModeInfo.IHTotal / 2;
2388   3                  CScalerSetByte(_IV_DV_DELAY_CLK_EVEN_42, (ustemp - 16) / 16);
2389   3              } 
2390   2      //V400 modify  
2391   2              CScalerSetBit(_FS_DELAY_FINE_TUNING_43, ~(_BIT1), _BIT1);       
2392   2              }
2393   1      }
2394          #endif
2395          
2396          #if(_HDMI_SUPPORT == _ON)
2397          //730702***
2398          void CAdjustHdmiCbCr422(void)
2399          {
2400   1              if(stModeInfo.IVHeight <= 288)
2401   1              {
2402   2                      CScalerPageSelect(_PAGE2);
2403   2              CScalerGetDataPortByte(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_ACRCR_51, 1, pData, _NON_AUTOINC);
2404   2      
2405   2                      CScalerPageSelect(_PAGE0);
2406   2                      if((pData[0] & 0x30) == 0x10)
2407   2                      {               
2408   3                              CTimerWaitForEvent(_EVENT_IVS);
2409   3                              pData[0] = HIBYTE(stModeInfo.IHTotal - 2);
2410   3                              pData[1] = 0x02;
2411   3                              pData[2] = LOBYTE(stModeInfo.IHTotal - 2);
2412   3                              pData[3] = HIBYTE(stModeInfo.IVTotal - 2);
2413   3                              pData[4] = 0x02;
2414   3                              pData[5] = LOBYTE(stModeInfo.IVTotal - 2);
2415   3                              pData[6] = 0x00;
2416   3                              pData[7] = 0x00;
2417   3                              pData[8] = 0x00;
2418   3                              pData[9] = 0x00;
2419   3                              pData[10] = 0x03;
2420   3                              pData[11] = 0x00;
2421   3                              pData[12] = 0x00;
2422   3                              pData[13] = 0x81;
2423   3                              CScalerWrite(_H_BOUNDARY_H_70, 14, pData, _AUTOINC);
2424   3                              pData[0]    = CAutoWaitFinish();
2425   3                      //if(pData[0] != _ERROR_SUCCESS)
2426   3                              //DebugPrintf("\nmeasure result = %x",pData[0]);        
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 41  

2427   3      
2428   3                              CScalerRead(_V_START_END_H_7E, 6, pData, _AUTOINC);
2429   3                              usHStartPos = (((WORD) pData[3] & 0xf0) << 4) | (WORD) pData[4];
2430   3                              usHEndPos = (((WORD) pData[3] & 0x0f) << 8) | (WORD) pData[5];
2431   3                              usVStartPos = (((WORD) pData[0] & 0xf0) << 4) | (WORD) pData[1];
2432   3                              usVEndPos = (((WORD) pData[0] & 0x0f) << 8) | (WORD) pData[2];                  
2433   3      
2434   3                              pData[0]    = ((usHStartPos >> 4) & 0x70) | (HIBYTE(usHStartPos) & 0x0f);
2435   3                              pData[1]    = (LOBYTE(usHStartPos)+0);
2436   3                              pData[2]    = (LOBYTE(usHStartPos)+0);
2437   3                              pData[3]    = (HIBYTE(usVStartPos) & 0x0f);
2438   3                              pData[4]    = (LOBYTE(usVStartPos)+0);
2439   3                              pData[5]    = (LOBYTE(usVStartPos)+0);
2440   3                              CScalerWrite(_H_BOUNDARY_H_70, 6, pData, _AUTOINC);     
2441   3      
2442   3                              CScalerSetByte(_AUTO_ADJ_CTRL1_7D, 0x20);
2443   3              
2444   3                              CScalerSetByte(_AUTO_ADJ_CTRL0_7A, 0x00|_BIT1);//red    
2445   3                              CScalerSetBit(_AUTO_ADJ_CTRL1_7D, ~_BIT0 , _BIT0);//start
2446   3      
2447   3                              pData[0] = CAutoWaitFinish();
2448   3                              //if(pData[0] != _ERROR_SUCCESS)       
2449   3                                      //DebugPrintf("\nmeasureMAX_R result = %x",pData[0]);
2450   3      
2451   3                              CScalerRead(_AUTO_PHASE_0_87, 1, &pData[1], _AUTOINC);
2452   3                              //DebugPrintf("\n****RED**** = %x",pData[1]);
2453   3              
2454   3                              CScalerSetByte(_AUTO_ADJ_CTRL0_7A, 0x00);//blue 
2455   3                              CScalerSetBit(_AUTO_ADJ_CTRL1_7D, ~_BIT0 , _BIT0);//start
2456   3      
2457   3                              pData[0] = CAutoWaitFinish();
2458   3                              //if(pData[0] != _ERROR_SUCCESS)       
2459   3                                      //DebugPrintf("\nmeasureMAX_B result = %x",pData[0]);
2460   3      
2461   3                              CScalerRead(_AUTO_PHASE_0_87, 1, &pData[2], _AUTOINC);
2462   3                              //DebugPrintf("\n****BLUE**** = %x",pData[2]);  
2463   3      
2464   3                              if((pData[1] != 0) || (pData[2] != 0))
2465   3                              {
2466   4                                      //DebugPrintf("\n\n=========MODIFY!!!!=========  \n\n",'0');
2467   4                      CScalerRead(_IPH_ACT_STA_L_15, 1, pData, _NON_AUTOINC);                 
2468   4                                      pData[0] = pData[0] - 1 ;
2469   4                                      CScalerSetBit(_VGIP_CTRL_10, ~(_BIT4) , 0x00);
2470   4                                      CScalerSetByte(_IPH_ACT_STA_L_15, pData[0]);
2471   4                                      CScalerSetBit(_VGIP_CTRL_10, ~(_BIT4) , _BIT4);
2472   4                              }
2473   3                      }
2474   2              }
2475   1      }
2476          //730702###
2477          //731301***
2478          //--------------------------------------------------
2479          // Description  : Enable HDMI watch dog
2480          // Input Value  : ucPar --> Parameter for HDMI watch dog
2481          // Output Value : None
2482          //--------------------------------------------------
2483          void CAdjustEnableHDMIWatchDog(BYTE ucPar)
2484          {
2485   1          CScalerPageSelect(_PAGE2);  //Issac-0129-Fixed
2486   1      
2487   1          if((ucPar & _WD_SET_AVMUTE_ENABLE) == 0x01)
2488   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_WDCR0_31, ~_BIT7, _BIT7); //Enable Set_AVMut
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 42  

             -e Watch Dog
2489   1      
2490   1          if((ucPar & _WD_AUDIO_FOR_TMDS_CLOCK) == 0x02)
2491   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_WDCR1_32, ~_BIT7, _BIT7);//Enable Audio Watc
             -h Dog for TMDS clock
2492   1      
2493   1          if((ucPar & _WD_PACKET_VARIATION) == 0x04)
2494   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_VWDSR_41, ~_BIT0, _BIT0);//Enable packet var
             -iation Watch Dog
2495   1      
2496   1          if((ucPar & _WD_AUDIO_FIFO) == 0x08)
2497   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_WDCR0_31, ~(_BIT2 | _BIT1), (_BIT2 | _BIT1))
             -; //Enable Audio Watch Dog
2498   1      }
2499          
2500          //--------------------------------------------------
2501          // Description  : Disable HDMI watch dog
2502          // Input Value  : ucPar --> Parameter for HDMI watch dog
2503          // Output Value : None
2504          //--------------------------------------------------
2505          void CAdjustDisableHDMIWatchDog(BYTE ucPar)
2506          {
2507   1          CScalerPageSelect(_PAGE2);  //Issac-0129-Fixed
2508   1      
2509   1          if((ucPar & _WD_SET_AVMUTE_ENABLE) == 0x01)
2510   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_WDCR0_31, ~_BIT7, 0x00); //Disable Set_AVMut
             -e Watch Dog
2511   1      
2512   1          if((ucPar & _WD_AUDIO_FOR_TMDS_CLOCK) == 0x02)
2513   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_WDCR1_32, ~_BIT7, 0x00);//Disable Audio Watc
             -h Dog for TMDS clock
2514   1      
2515   1          if((ucPar & _WD_PACKET_VARIATION) == 0x04)
2516   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_VWDSR_41, ~_BIT0, 0x00);//Disable packet var
             -iation Watch Dog
2517   1      
2518   1          if((ucPar & _WD_AUDIO_FIFO) == 0x08)
2519   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_WDCR0_31, ~(_BIT2 | _BIT1), 0x00); //Disable
             - Audio Watch Dog
2520   1      }
2521          #endif
2522          //731301###
2523          
2524          
2525          //------------------------------------------------------------
2526          //                MCU DAC function
2527          //------------------------------------------------------------
2528          void CSetPWM(BYTE PWMId, WORD Value)
2529          {         
2530   1          BYTE ucPWMData = 0;
2531   1      
2532   1      /*
2533   1           switch(PWMId)
2534   1           {
2535   1               case _SCALAR_PWM0:             // Scalar PWM
2536   1               case _SCALAR_PWM1:
2537   1               case _SCALAR_PWM2:
2538   1                   pData[0] = PWMId << 6;     // PWM ID
2539   1                   pData[1] = 0x01;
2540   1                   pData[2] = Value;
2541   1                   CScalerWrite(_OSD_ADDR_MSB_90,3,pData,_AUTOINC);
2542   1                   break;
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 43  

2543   1      
2544   1      #if(_MCU_TYPE == _MYSON_MTV512 || _MCU_TYPE == _RTD_2120)
2545   1               case _MCU_PWM0:
2546   1               case _MCU_PWM1:
2547   1               case _MCU_PWM2:
2548   1                    CSetMCUPWM(PWMId - _MCU_PWM0,Value);
2549   1                    break;
2550   1      
2551   1               case _MCU_PWM3:
2552   1               case _MCU_PWM4:
2553   1               case _MCU_PWM5:
2554   1                    CSetMCUPWM(PWMId - _MCU_PWM3,Value);
2555   1                    break;
2556   1      #endif
2557   1           }  */
2558   1           switch(PWMId)
2559   1           {
2560   2           case 0:  // PWM0
2561   2      /*         ucPWMData = MCU_PWM01L_DUT_FF4C;
2562   2               MCU_PWM0H_DUT_FF4A  = (Value >> 4) & 0xFF;
2563   2               MCU_PWM01L_DUT_FF4C = (ucPWMData & 0xF0) | ((BYTE)Value & 0x0F); */
2564   2               MCU_PWM0H_DUT_FF4A  = Value;
2565   2               break;
2566   2      
2567   2           case 1:  // PWM1
2568   2      /*         ucPWMData = MCU_PWM01L_DUT_FF4C;
2569   2               MCU_PWM1H_DUT_FF4B  = (Value >> 4) & 0xFF;
2570   2               MCU_PWM01L_DUT_FF4C = (ucPWMData & 0x0F) | (((BYTE)Value & 0x0F) << 4); */
2571   2               MCU_PWM1H_DUT_FF4B  = Value;
2572   2               break;
2573   2      
2574   2           case 2:  // PWM2
2575   2      /*         ucPWMData = MCU_PWM23L_DUT_FF4F;
2576   2               MCU_PWM2H_DUT_FF4D  = (Value >> 4) & 0xFF;
2577   2               MCU_PWM23L_DUT_FF4F = (ucPWMData & 0xF0) | ((BYTE)Value & 0x0F);*/
2578   2               MCU_PWM2H_DUT_FF4D  = Value;
2579   2               break;
2580   2      
2581   2           case 3:  // PWM3
2582   2      /*         ucPWMData = MCU_PWM23L_DUT_FF4F;
2583   2               MCU_PWM3H_DUT_FF4E  = (Value >> 4) & 0xFF;
2584   2               MCU_PWM23L_DUT_FF4F = (ucPWMData & 0x0F) | (((BYTE)Value & 0x0F) << 4); */
2585   2               MCU_PWM3H_DUT_FF4E  = Value;
2586   2               break;
2587   2      
2588   2           case 4:  // PWM4
2589   2      /*         ucPWMData = MCU_PWM45L_DUT_FF52;
2590   2               MCU_PWM4H_DUT_FF50  = (Value >> 4) & 0xFF;
2591   2               MCU_PWM45L_DUT_FF52 = (ucPWMData & 0xF0) | ((BYTE)Value & 0x0F); */
2592   2               MCU_PWM4H_DUT_FF50  = Value;
2593   2               break;
2594   2      
2595   2           case 5:  // PWM5     
2596   2      /*         ucPWMData = MCU_PWM45L_DUT_FF52;
2597   2               MCU_PWM5H_DUT_FF51  = (Value >> 4) & 0xFF;
2598   2               MCU_PWM45L_DUT_FF52 = (ucPWMData & 0x0F) | (((BYTE)Value & 0x0F) << 4); */
2599   2               MCU_PWM5H_DUT_FF51  = Value;
2600   2               break;
2601   2      
2602   2           }
2603   1      }
2604          
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 44  

2605          #if(_OSD_TYPE != _OSD007)
2606          void CAdjustGammaTable(BYTE index)
2607          {
2608   1          index = index;
2609   1      #if(_GAMMA_TYPE ==      _FULL_GAMMA_NORMAL_TABLE)
2610   1              switch(index)
2611   1          {
2612   2              case 1:
2613   2                      CAdjustGamma(_FULL_GAMMA_NORMAL_TABLE, GAMMA_1_R, GAMMA_1_G, GAMMA_1_B);
2614   2                      break;
2615   2      
2616   2              case 2:
2617   2                      CAdjustGamma(_FULL_GAMMA_NORMAL_TABLE, GAMMA_2_R, GAMMA_2_G, GAMMA_2_B);
2618   2                      break;
2619   2      
2620   2              case 3:
2621   2                      CAdjustGamma(_FULL_GAMMA_NORMAL_TABLE, GAMMA_3_R, GAMMA_3_G, GAMMA_3_B);
2622   2                      break;
2623   2      
2624   2              case 0:
2625   2                      CScalerSetBit(_GAMMA_CTRL_67, ~_BIT6, 0x00);
2626   2                      break;
2627   2      
2628   2              default:
2629   2                      break;
2630   2              }
2631   1              
2632   1      #elif(_GAMMA_TYPE == _FULL_GAMMA_COMPRESS_TABLE2)
              
                      switch(index)
                  {
                      case 0:         // disable Gamma
                              CScalerSetBit(_GAMMA_CTRL_67, ~_BIT6, 0x00);
                              break;
              
                      case 1:
                      CAdjustGamma(_FULL_GAMMA_COMPRESS_TABLE2, GAMMA_1_R, GAMMA_1_G, GAMMA_1_B);
                      break;
              
                  case 2:
                      CAdjustGamma(_FULL_GAMMA_COMPRESS_TABLE2, GAMMA_2_R, GAMMA_2_G, GAMMA_2_B);
                      break;
              
                  case 3:
                      CAdjustGamma(_FULL_GAMMA_COMPRESS_TABLE2, GAMMA_3_R, GAMMA_3_G, GAMMA_3_B);
                      break;
                  
                  default:
                      break;
                      }
              #endif
2656   1      }
2657          #endif
2658          
2659          //-------------------------------------------------
2660          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8700    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =      1     167
C51 COMPILER V7.20   ADJUST                                                                10/05/2015 09:30:04 PAGE 45  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     15    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
